# 一、概述

LLVM IR 是一种基于**静态单赋值（Static Single Assignment, SSA）**的中间表示形式。

 1. 它具备**类型安全**、**底层操作能力**、**灵活性**等特性；能够简洁地表示几乎所有高级编程语言（极少数动态语言的极端语义需要通过 LLVM IR 结合运行时库来实现）。

 2. 它表示是 LLVM 编译流程中**所有阶段**所共用的核心代码的表示形式。

 3. 它具备三种**完全等价**的表示形态：

    a. **内存中的编译器中间表示（IR）**

    b. **磁盘上的字节码表示**（适用于即时编译器的快速加载）

    c. **人类可读的汇编语言表示**。

4. 其设计目的是**轻量化、底层化**，同时兼顾**表达性、强类型化与可扩展性**。

5.  几乎所有的高级语言的语义（如面向对象的虚函数、函数式的闭包）都能被清晰的映射到LLVM IR上面。

   这点LLVM IR类似于不同微处理器架构的不同指令集的定位。他们的异同点如下：

   **a. 共同点：**

   ​	i. 他们都足够底层（比如针对 Python 的 pyc因为太过高层就不能做到“通用”）。 

   ​		LLVM IR 接近机器码，支持内存操作、寄存器级别的计算、位运算等； 指令集则直接对应硬件的执行动作（寄存器操作、内存访问、ALU 运算），是硬件能理解的最低级语言。

   ​	ii. 因为太底层他们相比于高层IR也会失去部分灵活性。

   ​		与其对应的高层IR，比如**Tensor IR**，则保留了于领域相关的高层语义，这使得基于他们**更容易**完成诸如深度学习的算子融合、数学等价转换等优化。而LLVM IR更擅长于通用底层优化（如常量传播、死代码消除、循环展开、寄存器分配）。 同时，LLVM IR通过**元数据（Metadata）**、**调试信息（Debug Info）**、**函数属性（Function Attributes** 等机制，保留部分高层语言的语义信息，这使得基于它也能完成部分高层优化（如函数内联、虚函数去虚拟化等）。

   ​	iii.  LLVM IR是“多对多”的**中间软件适配层**（多语言-> LLVM IR ->多目标架构）；指令集是“多对多”的**硬件 / 软件的边界规范**（多语言->具体指令集->具体CPU）。

   

   **b. 不同点：**

   ​	i. LLVM IR是**强静态类型**的（要求每个操作都又明确的类型，比如i32，ptr，{i64，i32}等）；指令集只具备**硬件级别的类型约束**（不同指令要求的操作数不同，比如`addl %eax, %ebx`要求操作数是 32 位通用寄存器）

   ​	ii. LLVM IR是架构无关的，指令集是架构（X86或者ARM或者RISCV）相关的。

6. LLVM IR汇编语言是合规的，比如“在使用一个变量之前必须定义好”。LLVM 基础架构提供了一个**验证优化**pass，它会在解析器完成代码解析之后和优化器输出字节码之前自动运行。

# 二、语法

## 2.1 标识符

​	LVM 标识符分为两种基本类型：**全局标识符**与**局部标识符**。全局标识符（函数、全局变量）以字符 `@` 开头；局部标识符（寄存器名称、类型）以字符 `%` 开头。

​	标识符有三种不同的格式，分别适用不同的场景：

1. **命名值**

​	由前缀字符与后续字符串构成，例如 `%foo`、`@DivisionByZero`、`%a.really.long.identifier`。特殊字符可通过转义序列 `\xx` 表示。同时，在全局值的名称前添加前缀 `\01` 可**抑制名称改编（name mangling）**。

​	值的名称必须带前缀，这样的话不用担心值与保留字冲突。LLVM 的保留字与其他编程语言的保留字特性十分相似，涵盖各类操作码关键字（如 `add`、`bitcast`、`ret` 等）、原始类型名称关键字（如 `void`、`i32` 等）及其他专用关键字。

2. **未命名值**

   由前缀字符与无符号数值构成，例如 `%12`、`@2`、`%44`。

3. **常量**

​	常量中可以引用标识符，比如：

```clojure
{ i32 4, float 17.0, ptr @G }  ;结构体常量引用全局标识符@G
!{!0, i32 0, ptr @global}      ;元数据常量引用元数据标识符!0和全局标识符@global
```

​	*注意：常量是指实体的固定属性，类比于人的身高、体重等；标识符则代指某个实体，比如：张三、李四。*

## 2.2 字符串常量

​	字符串常量由双引号 `"` 包裹，字符串内的所有字节均按字面意义处理，除非：

- 反斜杠 `\` 用于标识转义序列的起始；比如：`"Hello\20World"` 

- 在跨行长字符串中，第一个双引号 `"` 用于标识字符串的结束。比如：

  ```clojure
  "Hello
  World\22!" 
  ```

​	字符串常量的具体解释方式（例如字符编码格式），取决于其所处的上下文环境。

​	需要注意的是，不是所有的双引号 `"` 包裹都是字符串常量，它还可以是标识符的一部分，比如：
```clojure
%"my identifier"  ;用引号包裹的字符串形式构造标识符，支持空格
@"func#123"       ;支持特殊符号#
```

# 三、高层结构

## 3.1 模块

​	所有的LLVM程序都是由若干模块构成的，每个模块对应了输入程序的一个**翻译单元**（编译器前端的最小输入单元，通常对应了一个.c或者.cpp源文件加其直接或者间接包含的头文件）。

​	模块由llvm的链接器合并。合并的内容包括：

1. **函数 / 全局变量**：合并定义（解决重复定义）、解析前置声明（将`declare`补充为`define`）、统一链接类型（如`external`→`private`）；
2. **符号表（Symbol Table）**：合并所有模块的符号条目，去重并建立统一的 “符号 - 实体” 映射；
3. **元数据**：按特定规则合并，且**完整保留在最终模块中**。

​	模块的构成分成全局变量的定义和申明、函数的定义与申明、元数据的命名：

```clojure
; 声明字符串常量为全局常量
@.str = private unnamed_addr constant [13 x i8] c"hello world\0A\00"

; 声明 puts 函数的外部引用
declare i32 @puts(ptr captures(none)) nounwind

; 定义 main 函数
define i32 @main() {
  ; 调用 puts 函数，将字符串输出至标准输出
  call i32 @puts(ptr @.str)
  ret i32 0
}

; 命名元数据
!0 = !{i32 42, null, !"string"}
!foo = !{!0}
```

## 3.2 链接类型

所有的全局变量和函数都具有以下类型的链接属性之一：

| 链接类型               | 核心语义                                                     | 适用对象（定义 / 声明） | 关键特性与限制                                               | 对应语言 / 场景参考               |
| ---------------------- | ------------------------------------------------------------ | ----------------------- | ------------------------------------------------------------ | --------------------------------- |
| `private`              | 仅当前模块可访问，不会进入目标文件符号表                     | 仅定义                  | 可重命名以避免冲突；无外部可见性                             | -                                 |
| `internal`             | 仅当前模块可访问，会以局部符号（ELF: `STB_LOCAL`）进入目标文件符号表 | 仅定义                  | 等价于 C 语言 `static` 关键字的语义                          | C 全局 `static` 变量 / 函数       |
| `available_externally` | 定义在外部模块，当前模块仅用于优化（内联等），不输出到目标文件 | 仅定义                  | 可被任意丢弃；支持优化；**不能用于声明**                     | 跨模块优化的外部函数定义          |
| `linkonce`             | 链接时同名合并，未引用可丢弃                                 | 仅定义                  | 不支持内联优化；可实现模板 / 内联函数的多编译单元生成        | C++ 模板实例化、轻量级内联函数    |
| `linkonce_odr`         | 同 `linkonce`，但遵循 C++ ODR 规则，保证同名定义等价         | 仅定义                  | 支持内联和常量折叠优化                                       | 符合 ODR 的 C++ 模板 / 内联函数   |
| `weak`                 | 链接时同名合并，未引用**不可丢弃**                           | 定义 / 声明             | 等价于 C 语言 `__attribute__((weak))`<br />*ps: weak 属性可以从声明继承到实现，所以通常使用**弱申明强实现**来工程应用* | C 弱引用符号                      |
| `common`               | 用于 C 暂定定义，链接时同名合并，未引用不可丢弃              | 仅定义                  | 必须零初始化、无显式段、不能标记 `constant`；不支持函数 / 别名 | C 全局未定初值变量（如 `int x;`） |
| `appending`            | 仅适用于指针数组类型全局变量，链接时数组拼接                 | 仅定义                  | 类型安全的段拼接；仅支持 LLVM 特殊变量（如 `llvm.global_ctors`） | LLVM 全局构造函数数组             |
| `extern_weak`          | 弱引用，未链接则符号为空值，不产生未定义引用错误             | 仅声明                  | 遵循 ELF 弱引用模型                                          | 跨模块弱引用声明                  |
| `weak_odr`             | 同 `weak`，但遵循 C++ ODR 规则，保证同名定义等价             | 定义 / 声明             | 支持优化；可被覆盖                                           | 符合 ODR 的 C++ 弱符号            |
| `external`             | 外部可见，参与跨模块链接                                     | 定义 / 声明             |                                                              |                                   |

PS：C++的ODR规则本质是一种“**语义 + 链接约束**”：

1. 对非特殊实体（如全局变量、非 inline 函数）必须「一处定义、多处声明」；（C语言也有类似的规则，对于函数来说可多处申明，但是函数的实现只能在一个c文件中。对于全局变量来说，对带有extern的申明可多处，不带有extern，有类型但是没赋值的“暂时定义”可以放置多处<这儿违反了C++的ODR>，链接时候合并。在此基础上有赋值的则严格遵循一处。）
2. 特殊实体（inline/constexpr/ 模板/struct/class）允许「多处定义」，但所有定义必须完全一致(如果不一样，C++中也当成了undfined behavoir，实现成本太高，所以所有编译器都没有实现这种错误的显示报告)，且编译器 / 链接器最终会将其合并为**全局唯一实例**；

从而达到“避免链接冲突、保证内存布局 / 语义一致，消除运行时未定义行为”的目的

## 3.3 可见性

​	所有的全局变量和函数都具备以下的**可见性类型**之一：

1. **default**

   ​	在ELF目标文件格式的平台上，默认可见性意味着该符号可以被其他模块看见；如果该符号位于其他共享库中，那么意味着该符号对应的实体还可以被重写。

   ​	*跟weak链接类型的区别：weak是针对链接也就是.o文件的，是在编译期间就确定的行为；default可见性在共享库的情况是针对运行时的，运行期决定，而且可以动态调整。*

2. **hidden**

   ​	隐藏可见性意味着该符号不会被加入动态符号表，因此其他模块（可执行文件或共享库）**无法直接引用**该符号。

3. **protected**

   ​	在 ELF 格式下，受保护可见性意味着该符号会被加入动态符号表，但**定义该符号的模块内部对其的引用，会绑定到本地符号**。也就是说，该符号无法被其他模块重写。

   

   ​	所以，链接类型决定了同一程序内多个编译单元对符合的处理规则；而符号可见性则规定了加载器层面，符号是否能跨模块（可执行文件和共享库）访问能力。

## 3.4 调用约定

​	LLVM 的函数、函数调用（`call`）和函数调用并伴随异常处理（`invoke`）均可为调用操作指定一个可选的调用约定。常见的又fastcc，tailcc，swiftcc等，**这类调用约定更倾向于是LLVM IR层的调用契约**，后端会根据这些内容决定如何进行lowering。进而决定哪些变化是合法的、成本模型如何评估和后端寄存器的分配策略。

---

> 📌**成本模型**
>
> 成本模型不是LLVM中的一个“统一公式”，而是一套分布在不同pass和analysis中的启发式评估体系（这种“用经验规则/阈值/估算值替代精确求解”的方法就叫做启发式评估）。calling convention会被纳入到调用相关的成本模型上。比如，内联决策依赖的就是一个InlineCost，看最终的成本是否低于阈值（threshold），收益足够大（benefit outweigh cost）以及是否违反了硬约束（例如递归、可见性、必须不内联等）。一个直观例子：
>
> - `preserve_allcc` 的 callee 需要保存大量寄存器。每次 call 都要 save/restore 一堆寄存器， 这意味着不内联的成本更高。
> - 而`fastcc` 的参数多走寄存器。所以 call 的成本相对小，那么call的开销在内联成本模型中的的占比就不大，更多的要考虑内联以后可能带来的其他优化收益（比如常量传播，公共子表达消除等）

> 📌**ABI**
>
> ABI 是Application Binary Interface的缩写。他是一个多维度的规则的集合，共同绝对了高级语言如何一步一步转换成可被CPU执行的二进制文件。具体到：
>
> 1. **调用维度**：coalling convention （LLVM 的 `ccc/fastcc/...`，ARM上的 AAPCS ，x86_64上的systemv AMD64 ABI for linux和MS x64 ABI for windows也有对调用维度做规定，比如哪些寄存器用来参数传递，哪些寄存器是caller saved或callee saved等等）
> 2. **数据布局维度**：type size/alignment、struct layout（对应在llvm中的`datalayout`, 其他平台ABI也对这一维度有规定）
> 3. **符号维度**：mangling、链接名、可见性
> 4. **异常/RTTI 维度**：unwind tables、personality、typeinfo 布局
> 5. **系统调用维度**：syscall number、寄存器约定



> 📌**ABI的种类**
>
> 现存很多种ABI，可以归纳为四类：
>
> 1. platform ABI（AAPCS/AAPCS64、SysV AMD64、 MS x64）
>
>    在 LLVM 里最终体现为 Module 的 `target triple` + `datalayout` + 后端的 CC lowering 规则。通过一下三部分决定：
>
>    - `--target=<triple>`（或编译器默认 triple）
>    - `-march/-mcpu/-mfpu/-mfloat-abi/-mabi`（ARM 上尤其关键）
>    - 以及链接时的目标（ELF/COFF、relocation model 等）
>
> 2. C++ ABI（Itanium C++ ABI和MSVC C++ ABI）
>
>    由目标环境决定（例如 `x86_64-pc-windows-msvc` 通常走 MSVC C++ ABI；`*-linux-gnu` 多数走 Itanium 风格）或者由编译器家族/模式决定（Clang-cl 倾向 MSVC 生态）。
>    程序员常见“显式控制”的点反而是一些细节开关：比如 `-fabi-version=`、`-fno-exceptions`、`-fno-rtti`（这些会改变可见的 ABI 交互面），但很少有人“选择 Itanium ABI”作为一个独立选项，因为它基本跟着 triple/工具链走。
>
> 3. lib ABI（libc/libstdc++和 libc++/unwind 运行库）
>
>    这层决定了“你最终跟谁二进制互操作”，也就决定了你必须遵守哪套库 ABI。比如：
>
>    - 通过`--sysroot=...`、选择 glibc/musl/newlib 等哪个libc库。
>    - 通过`-stdlib=libstdc++` 或 `-stdlib=libc++`选择哪个c++标准库。
>    - 通过`-rtlib=compiler-rt` vs `libgcc`，`-unwindlib=libunwind` 等选择哪个运行库。（提供异常、new/delete、线程、启动代码、TLS 机制、动态链接器等功能）
>    - 通过`-static`、`-static-libstdc++`…选择静/动态链接策略。
>
> 4. 内核和系统调用ABI（ `*-linux-gnu` vs `*-none-eabi`）
>
>    更多由 **OS triple** 决定（例如 `*-linux-gnu` vs `*-none-eabi`），但日常开发里你通常不直接写 syscall，而是通过 libc/rt 的封装去用；因此程序员感知到的控制点通常是：
>
>    - 目标 OS/环境：triple、sysroot、链接器
>    - 是否裸机：`none-eabi`（没有“内核 ABI”，只有你自己的 runtime/semihosting 约定）

> 📌**ABI汇总**
>
> | 规范 / ABI                                   | 调用维度<br />（call conv）                                  | 数据布局维度（type/align/<br />struct）                      | 符号维度（mangling/链接名/可见性）                           | 异常/RTTI 维度（unwind/<br />personality/<br />typeinfo）    | 系统调用维度（syscall # / regs）                  | 对象文件/<br />动态链接维度（ELF/COFF/reloc）          |
> | -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------- | ------------------------------------------------------ |
> | **SysV AMD64 psABI**                         | ✅（寄存器传参、callee/caller-save、栈对齐、varargs 等）      | ◐（基础类型与对齐、部分 aggregate 规则；C++ 对象另靠 C++ ABI） | ◐（链接层符号/可见性规则；不定义 C++ mangling）              | ◐（通常与 DWARF EH/unwind 约定组合使用）                     | —（Linux syscall ABI 另算）                       | ✅（ELF、relocation、PLT/GOT 等是核心内容之一）         |
> | **MS x64 ABI（Windows 用户态）**             | ✅（RCX/RDX/R8/R9、shadow space、save/restore 等）            | ◐（基础类型布局与对齐；生态由 MSVC 约定补齐）                | ◐（链接符号规则更多由 COFF/PE + 工具链约定；C++ mangling 另在 MSVC C++ ABI） | ◐（与 Windows unwind/SEH + C++ runtime 组合）                | —（Windows syscall 不作为稳定 ABI 对外承诺）      | ✅（COFF/PE、unwind 元数据等）                          |
> | **AAPCS / AAPCS64（ARM 过程调用标准）**      | ✅（参数/返回、保存规则、栈对齐、VFP/浮点变体等）             | ◐（基础布局/对齐/aggregate 规则；更完整平台 ABI 需结合 ELF/平台文档） | —/◐（本身不主谈符号；链接/符号多由 ELF for ARM/AArch64 补）  | ◐（AArch32 常见 EHABI；AArch64 常见 DWARF EH，需 runtime 组合） | —（Linux/裸机 syscall 或 semihosting 另算）       | ◐（通常需要与 ELF for ARM/AArch64 一起构成“平台 ABI”） |
> | **ELF gABI / 平台 ELF ABI（统称）**          | —/◐（不主谈 call；但会约束一些与调用相关的对象表示）         | —/◐（少量类型/对齐可能被引用；主体不在这）                   | ◐（符号表、可见性、版本等“链接符号维度”）                    | ◐（.eh_frame/.ARM.exidx 等编码属于对象文件层）               | —                                                 | ✅（ELF 文件格式、重定位、动态链接、符号版本）          |
> | **Itanium C++ ABI（常见于 Linux/ELF 生态）** | —（不规定寄存器传参细节）                                    | ✅（C++ 对象布局：vtable/继承/虚基类等语义层布局约定；底座仍依赖 datalayout） | ✅（C++ 名字改编规则是核心）                                  | ✅（RTTI/typeinfo、异常对象与 catch 匹配接口等）              | —                                                 | ◐（会依赖 ELF/DWARF 约定落地，但不以其为主）           |
> | **MSVC C++ ABI（Windows C++ 生态）**         | —/◐（调用维度主要由 MS x64 ABI；但某些 thiscall 等历史约定与编译器相关） | ✅（C++ 对象布局/vftable/vbtable 等）                         | ✅（MSVC 风格 mangling）                                      | ✅（与 SEH/unwind + MSVC runtime 的 C++ 异常/RTTI 契约）      | —                                                 | ◐（落地在 COFF/PE + PDB/UNWIND_INFO 等）               |
> | **Linux kernel ABI（syscall ABI + UAPI）**   | —                                                            | ◐（UAPI 结构体布局：stat、ioctl 结构等是 ABI 的一部分）      | —                                                            | —                                                            | ✅（syscall 号、寄存器/指令约定、errno 语义等）    | —                                                      |
> | **libc ABI（glibc/musl/newlib 等）**         | ◐（通常“继承平台 ccc”；自身不另造 call conv）                | ◐（若暴露类型布局则成为承诺；大量类型可做不透明化）          | ✅（导出符号集合、符号版本：glibc 很典型）                    | —/◐（libc 本身少；但 unwind/threads 相关接口可能牵涉）       | ◐（提供 syscall 封装；但 syscall ABI 本体归内核） | ◐（动态链接行为/符号版本与 ELF 强相关）                |
> | **C++ 标准库 ABI（libstdc++ / libc++）**     | ◐（继承平台 call ABI）                                       | ✅/◐（很多标准库类型布局属于 ABI：如 string/vector 的实现细节） | ✅（大量模板实例符号、符号版本/命名空间内符号约定）           | ✅/◐（异常类型、typeinfo、new/delete 等与 C++ ABI/运行库强耦合） | —                                                 | ◐（与 ELF/COFF 链接、符号可见性强耦合）                |

---



## 3.5 运行时抢占说明符号

​	全局变量、函数和别名可以带有可选的运行时抢占说明符。它们用于告诉优化和后端生成器一个全局符号在运行时是否可能被“符号抢占”（interposition），从而决定是否需要经由 GOT/PLT 间接访问，能否进行更激进的优化。若未显式指定抢占说明符，则该符号默认视为 dso_preemptable。

1. dso_preemptable 

   表示该函数或变量在运行时可能被来自链接单元之外的符号替换。需要通过 GOT 加载地址或通过 PLT 调用，编译器也不能假设取到的是本 DSO 的地址，从而限制了一些跨边界优化。

2. dso_local 

   编译器可以假定标记为 dso_local 的函数或变量会解析为同一链接单元内的符号。在代码生成阶段，就可以直接用PC相对寻址或者直接调用，不使用GOT/PLT；取地址的也可以被当成常量处理，从而启动更多优化。即使其定义不在当前编译单元中，也会生成对其的直接访问。

## 3.6 非整数型指针类型



