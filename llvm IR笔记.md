# 一、概述

LLVM IR 是一种基于**静态单赋值（Static Single Assignment, SSA）**的中间表示形式。

 1. 它具备**类型安全**、**底层操作能力**、**灵活性**等特性；能够简洁地表示几乎所有高级编程语言（极少数动态语言的极端语义需要通过 LLVM IR 结合运行时库来实现）。

 2. 它表示是 LLVM 编译流程中**所有阶段**所共用的核心代码的表示形式。

 3. 它具备三种**完全等价**的表示形态：

    a. **内存中的编译器中间表示（IR）**

    b. **磁盘上的字节码表示**（适用于即时编译器的快速加载）

    c. **人类可读的汇编语言表示**。

4. 其设计目的是**轻量化、底层化**，同时兼顾**表达性、强类型化与可扩展性**。

5.  几乎所有的高级语言的语义（如面向对象的虚函数、函数式的闭包）都能被清晰的映射到LLVM IR上面。

   这点LLVM IR类似于不同微处理器架构的不同指令集的定位。他们的异同点如下：

   **a. 共同点：**

   ​	i. 他们都足够底层（比如针对 Python 的 pyc因为太过高层就不能做到“通用”）。 

   ​		LLVM IR 接近机器码，支持内存操作、寄存器级别的计算、位运算等； 指令集则直接对应硬件的执行动作（寄存器操作、内存访问、ALU 运算），是硬件能理解的最低级语言。

   ​	ii. 因为太底层他们相比于高层IR也会失去部分灵活性。

   ​		与其对应的高层IR，比如**Tensor IR**，则保留了于领域相关的高层语义，这使得基于他们**更容易**完成诸如深度学习的算子融合、数学等价转换等优化。而LLVM IR更擅长于通用底层优化（如常量传播、死代码消除、循环展开、寄存器分配）。 同时，LLVM IR通过**元数据（Metadata）**、**调试信息（Debug Info）**、**函数属性（Function Attributes** 等机制，保留部分高层语言的语义信息，这使得基于它也能完成部分高层优化（如函数内联、虚函数去虚拟化等）。

   ​	iii.  LLVM IR是“多对多”的**中间软件适配层**（多语言-> LLVM IR ->多目标架构）；指令集是“多对多”的**硬件 / 软件的边界规范**（多语言->具体指令集->具体CPU）。

   

   **b. 不同点：**

   ​	i. LLVM IR是**强静态类型**的（要求每个操作都又明确的类型，比如i32，ptr，{i64，i32}等）；指令集只具备**硬件级别的类型约束**（不同指令要求的操作数不同，比如`addl %eax, %ebx`要求操作数是 32 位通用寄存器）

   ​	ii. LLVM IR是架构无关的，指令集是架构（X86或者ARM或者RISCV）相关的。

6. LLVM IR汇编语言是合规的，比如“在使用一个变量之前必须定义好”。LLVM 基础架构提供了一个**验证优化**pass，它会在解析器完成代码解析之后和优化器输出字节码之前自动运行。

# 二、语法

## 2.1 标识符

​	LVM 标识符分为两种基本类型：**全局标识符**与**局部标识符**。全局标识符（函数、全局变量）以字符 `@` 开头；局部标识符（寄存器名称、类型）以字符 `%` 开头。

​	标识符有三种不同的格式，分别适用不同的场景：

1. **命名值**

​	由前缀字符与后续字符串构成，例如 `%foo`、`@DivisionByZero`、`%a.really.long.identifier`。特殊字符可通过转义序列 `\xx` 表示。同时，在全局值的名称前添加前缀 `\01` 可**抑制名称改编（name mangling）**。

​	值的名称必须带前缀，这样的话不用担心值与保留字冲突。LLVM 的保留字与其他编程语言的保留字特性十分相似，涵盖各类操作码关键字（如 `add`、`bitcast`、`ret` 等）、原始类型名称关键字（如 `void`、`i32` 等）及其他专用关键字。

2. **未命名值**

   由前缀字符与无符号数值构成，例如 `%12`、`@2`、`%44`。

3. **常量**

​	常量中可以引用标识符，比如：

```clojure
{ i32 4, float 17.0, ptr @G }  ;结构体常量引用全局标识符@G
!{!0, i32 0, ptr @global}      ;元数据常量引用元数据标识符!0和全局标识符@global
```

​	*注意：常量是指实体的固定属性，类比于人的身高、体重等；标识符则代指某个实体，比如：张三、李四。*

## 2.2 字符串常量

​	字符串常量由双引号 `"` 包裹，字符串内的所有字节均按字面意义处理，除非：

- 反斜杠 `\` 用于标识转义序列的起始；比如：`"Hello\20World"` 

- 在跨行长字符串中，第一个双引号 `"` 用于标识字符串的结束。比如：

  ```clojure
  "Hello
  World\22!" 
  ```

​	字符串常量的具体解释方式（例如字符编码格式），取决于其所处的上下文环境。

​	需要注意的是，不是所有的双引号 `"` 包裹都是字符串常量，它还可以是标识符的一部分，比如：
```clojure
%"my identifier"  ;用引号包裹的字符串形式构造标识符，支持空格
@"func#123"       ;支持特殊符号#
```

# 三、高层结构

## 3.1 模块

​	所有的LLVM程序都是由若干模块构成的，每个模块对应了输入程序的一个**翻译单元**（编译器前端的最小输入单元，通常对应了一个.c或者.cpp源文件加其直接或者间接包含的头文件）。

​	模块由llvm的链接器合并。合并的内容包括：

1. **函数 / 全局变量**：合并定义（解决重复定义）、解析前置声明（将`declare`补充为`define`）、统一链接类型（如`external`→`private`）；
2. **符号表（Symbol Table）**：合并所有模块的符号条目，去重并建立统一的 “符号 - 实体” 映射；
3. **元数据**：按特定规则合并，且**完整保留在最终模块中**。

​	模块的构成分成全局变量的定义和申明、函数的定义与申明、元数据的命名：

```clojure
; 声明字符串常量为全局常量
@.str = private unnamed_addr constant [13 x i8] c"hello world\0A\00"

; 声明 puts 函数的外部引用
declare i32 @puts(ptr captures(none)) nounwind

; 定义 main 函数
define i32 @main() {
  ; 调用 puts 函数，将字符串输出至标准输出
  call i32 @puts(ptr @.str)
  ret i32 0
}

; 命名元数据
!0 = !{i32 42, null, !"string"}
!foo = !{!0}
```

## 3.2 链接类型

所有的全局变量和函数都具有以下类型的链接属性之一：

| 链接类型               | 核心语义                                                     | 适用对象（定义 / 声明） | 关键特性与限制                                               | 对应语言 / 场景参考               |
| ---------------------- | ------------------------------------------------------------ | ----------------------- | ------------------------------------------------------------ | --------------------------------- |
| `private`              | 仅当前模块可访问，不会进入目标文件符号表                     | 仅定义                  | 可重命名以避免冲突；无外部可见性                             | -                                 |
| `internal`             | 仅当前模块可访问，会以局部符号（ELF: `STB_LOCAL`）进入目标文件符号表 | 仅定义                  | 等价于 C 语言 `static` 关键字的语义                          | C 全局 `static` 变量 / 函数       |
| `available_externally` | 定义在外部模块，当前模块仅用于优化（内联等），不输出到目标文件 | 仅定义                  | 可被任意丢弃；支持优化；**不能用于声明**                     | 跨模块优化的外部函数定义          |
| `linkonce`             | 链接时同名合并，未引用可丢弃                                 | 仅定义                  | 不支持内联优化；可实现模板 / 内联函数的多编译单元生成        | C++ 模板实例化、轻量级内联函数    |
| `linkonce_odr`         | 同 `linkonce`，但遵循 C++ ODR 规则，保证同名定义等价         | 仅定义                  | 支持内联和常量折叠优化                                       | 符合 ODR 的 C++ 模板 / 内联函数   |
| `weak`                 | 链接时同名合并，未引用**不可丢弃**                           | 定义 / 声明             | 等价于 C 语言 `__attribute__((weak))`<br />*ps: weak 属性可以从声明继承到实现，所以通常使用**弱申明强实现**来工程应用* | C 弱引用符号                      |
| `common`               | 用于 C 暂定定义，链接时同名合并，未引用不可丢弃              | 仅定义                  | 必须零初始化、无显式段、不能标记 `constant`；不支持函数 / 别名 | C 全局未定初值变量（如 `int x;`） |
| `appending`            | 仅适用于指针数组类型全局变量，链接时数组拼接                 | 仅定义                  | 类型安全的段拼接；仅支持 LLVM 特殊变量（如 `llvm.global_ctors`） | LLVM 全局构造函数数组             |
| `extern_weak`          | 弱引用，未链接则符号为空值，不产生未定义引用错误             | 仅声明                  | 遵循 ELF 弱引用模型                                          | 跨模块弱引用声明                  |
| `weak_odr`             | 同 `weak`，但遵循 C++ ODR 规则，保证同名定义等价             | 定义 / 声明             | 支持优化；可被覆盖                                           | 符合 ODR 的 C++ 弱符号            |
| `external`             | 外部可见，参与跨模块链接                                     | 定义 / 声明             |                                                              |                                   |

PS：C++的ODR规则本质是一种“**语义 + 链接约束**”：

1. 对非特殊实体（如全局变量、非 inline 函数）必须「一处定义、多处声明」；（C语言也有类似的规则，对于函数来说可多处申明，但是函数的实现只能在一个c文件中。对于全局变量来说，对带有extern的申明可多处，不带有extern，有类型但是没赋值的“暂时定义”可以放置多处<这儿违反了C++的ODR>，链接时候合并。在此基础上有赋值的则严格遵循一处。）
2. 特殊实体（inline/constexpr/ 模板/struct/class）允许「多处定义」，但所有定义必须完全一致(如果不一样，C++中也当成了undfined behavoir，实现成本太高，所以所有编译器都没有实现这种错误的显示报告)，且编译器 / 链接器最终会将其合并为**全局唯一实例**；

从而达到“避免链接冲突、保证内存布局 / 语义一致，消除运行时未定义行为”的目的

## 3.3 可见性

​	所有的全局变量和函数都具备以下的**可见性类型**之一：

1. **default**

   ​	在ELF目标文件格式的平台上，默认可见性意味着该符号可以被其他模块看见；如果该符号位于其他共享库中，那么意味着该符号对应的实体还可以被重写。

   ​	*跟weak链接类型的区别：weak是针对链接也就是.o文件的，是在编译期间就确定的行为；default可见性在共享库的情况是针对运行时的，运行期决定，而且可以动态调整。*

2. **hidden**

   ​	隐藏可见性意味着该符号不会被加入动态符号表，因此其他模块（可执行文件或共享库）**无法直接引用**该符号。

3. **protected**

   ​	在 ELF 格式下，受保护可见性意味着该符号会被加入动态符号表，但**定义该符号的模块内部对其的引用，会绑定到本地符号**。也就是说，该符号无法被其他模块重写。

   

   ​	所以，链接类型决定了同一程序内多个编译单元对符合的处理规则；而符号可见性则规定了加载器层面，符号是否能跨模块（可执行文件和共享库）访问能力。

## 3.4 调用约定

​	LLVM 的函数、函数调用（`call`）和函数调用并伴随异常处理（`invoke`）均可为调用操作指定一个可选的调用约定。**任意动态调用方与被调用方的调用约定必须匹配**，否则程序行为将属于未定义行为。以下列出的ABI都属于应用ABI的范畴。

## 3.5 运行时抢占说明符号

​	全局变量、函数和别名可以带有可选的运行时抢占说明符。它们用于告诉优化和后端生成器一个全局符号在运行时是否可能被“符号抢占”（interposition），从而决定是否需要经由 GOT/PLT 间接访问，能否进行更激进的优化。若未显式指定抢占说明符，则该符号默认视为 dso_preemptable。

1. dso_preemptable 

   表示该函数或变量在运行时可能被来自链接单元之外的符号替换。需要通过 GOT 加载地址或通过 PLT 调用，编译器也不能假设取到的是本 DSO 的地址，从而限制了一些跨边界优化。

2. dso_local 

   编译器可以假定标记为 dso_local 的函数或变量会解析为同一链接单元内的符号。在代码生成阶段，就可以直接用PC相对寻址或者直接调用，不使用GOT/PLT；取地址的也可以被当成常量处理，从而启动更多优化。即使其定义不在当前编译单元中，也会生成对其的直接访问。

## 3.6 非整数型指针类型



