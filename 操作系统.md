# 0.硬件

CPU本身支持特权模式和非特权模式，在特权模式下所有的指令都能够被执行

# 1. 进程

进程是一个用以区分其他进程的，由以下部分组成的一个context：

1. 程序的指令（.text）和全局数据（.data），这两部分是组成程序的主题。
2. 程序在运行过程中使用到的一些用户输入或者特定情境下的数据（stack与heap）。
3. 在操作系统中用于进程切换的CPU state（General register，Address register（取指的位置），Instruction register（指令寄存器，所有指令通过Address register）和Flags（对比指令执行的依据））。
4. 被该进程打开的文件（比如某个txt文件）或者分配给他的IO设备（比如键盘、鼠标等）。



操作系统通过ProcessControlBlock（PCB）来切换当前系统中的进程，它是一个数据结构包含了上面所提到的所有内容。它能在操作系统中表示一个进程，但是进程更为明确的定义还是一个不可拆分的包含了上面内容的一个上下文（Context）。

PCB的可能构造如下：

```rust
pub struct ProcessControlBlock {
    pid: u64, //进程ID
    sate: ProcessState, // 进程的状态
    
    //CPU states
    program_counter: u64, // Address register的快照
    instruction_register: u64, //Instruction register的快照
    general_purpose_register: [u64, 32], //通用寄存器的快照
    flags:[u1;3], //CPU的标志位
    stack_pointer: u64,
    index_registers: [u64; 2],
    
    memory_limits:[u64,2], //用在操作系统中限制进程的访问内存的区域，任何跳出这个区域的进程访问将会被当成错误，以保证安全性。
    
    io_devices: Vec<IO_Device>,
    open_files: Vec<File>,
    
    parent: Arc<ProcessControlBlock>,
    children: Vec<Arc<ProcessControlBlock>>
}
```

# 2. 处理器模式

​	每种处理器都会支持一个指令集（ISA），指令本身可被分成特权和非特权指令。CPU的运行模式可以分成特权模式（Kernel mode）和受限模式（User mode），在特权模式下指令集中的所有的指令都能够被执行，非特权模式下CPU只能执行部分非特权指令。通常，CPU通过一个特殊的寄存器ModeBit来区分当前CPU是在哪个模式下。

如下是ARM架构中常见的特权和非特权指令的总结：

|    **对比维度**     |                        **非特权指令**                        |                         **特权指令**                         |
| :----------------- | :----------------------------------------------------------  | :---------------------------------------------------------- |
|    **核心定义**     | 可在**所有处理器模式 / 异常级别**执行的通用指令，无系统资源操作权限 | 仅能在**特权模式 / 高异常级别**执行的指令，用于系统级资源管理与配置 |
|    **执行环境**     | - ARMv7：用户模式 + 所有特权模式<br />- ARMv8：EL0（非特权级别）+ EL1~EL3（特权级别） | - ARMv7：仅异常模式、系统模式<br />- ARMv8：仅 EL1~EL3（EL0 执行触发异常） |
| **典型指令 / 操作** | 1. 数据运算：`ADD`/`SUB`/`MUL`/`AND`/`ORR`<br />2. 寄存器传输：`MOV`/`MVN`<br />3. 用户态内存访问：`LDR`/`STR`（用户空间地址）<br />4. 控制流：`B`/`BL`/`BX`（非异常返回）<br />5. 栈操作：`PUSH`/`POP`（用户栈） | 1. 系统寄存器访问：`MRS`/`MSR`（`CPSR`/`SCTLR`）<br />、`MCR`/`MRC`（协处理器）<br />2. 内存管理MMU：`TLBI`（TLB 刷新）、内核空间`LDR`/`STR`<br />3. 模式 / 级别切换：修改`CPSR`模式位、`SMC`（TrustZone）<br />4. 异常触发：`SVC`（ARMv6+）、`SWI`（ARMv6 前）<br />5. 硬件配置：外设寄存器读写、中断控制 |
|  **资源访问范围**   | 仅限**用户空间**资源（应用程序内存、通用寄存器），无法访问内核 / 硬件资源 |    可访问**系统级资源**（内核内存、硬件寄存器、协处理器）    |
|  **异常触发条件**   |    在非特权模式下**访问特权资源**时，触发**数据中止异常**    |     在非特权模式下**直接执行**时，触发**未定义指令异常**     |
|    **应用场景**     |    应用程序逻辑计算、用户态数据处理、无系统资源依赖的代码    | 操作系统内核初始化、中断 / 异常处理、硬件驱动开发、虚拟化 / 安全扩展配置 |
| **ARMv8 关键变化**  |  仅 EL0 为专属非特权级别，指令权限由 `SCTLR_ELx` 寄存器约束  | EL1（内核）、EL2（虚拟化）、EL3（安全监控）均为特权级别，指令权限分级管控 |

# 3. 中断

​	CPU模式的切换通常使用中断（Interrupts）来实现。行为上看，中断像是发送给操作系统的一个信号，该信号会告诉操作系统当前有个事件（比如用户点击了鼠标）发生了，操作系统在接受到这个信号以后会暂停当前正在运行的进程，并且跳转到这个中断对应的执行代码位置。中断的执行通常包含了以下四部分内容：1. 存储被中断进程的状态。2. 处理中断。3. 恢复被中断进程的状态。4.继续执行被中断的进程。

​	普通的用户程序通过操作系统API也就是系统调用来触发某个特定的中断，所有的系统调用在实现中都会在显示的触发某个中断。例如下面的关于打开一个文件的系统调用：

```rust
fn open(filename: String):Result<...> {
    mov rax,2                 // system call number for open
    lea rdi, [ref filename]   // pointer to the file path in RDI(1st argument)
    mov rsi, 0                // File access flags (O_RDONLY = 0)
    mov rdx, 0                // Mode (unused here)
    int 0x80                  // trigger an interrupt
    ret                       // return to caller, file descriptor is in RAX
}
```

​	系统调用本质上相当于程序通过自我中断把CPU控制权交给了操作系统。普通的用户程序除了**主动**使用系统调用来放弃CPU控制权限之外，还可以被动的通过timer来放弃CPU控制权。timer在所有微处理器平台上都有集成（x86 的 PIT/HPET、ARM 的 Global Timer、RISC-V 的 CLINT），如果某个进程一直没有触发系统调用，那么在timer周期性归零以后就会触发定时器中断，在定时器中断中，操作系统会判断当前进程是否用完时间片、是否有更高优先级进程就绪，如果满足就触发进程切换。

​	除了timer之外，以下场景也能使得进程被动放弃CPU：

1. **IO中断触发**：当 I/O 完成时，**外设控制器触发硬件中断**（如磁盘中断、网卡中断），内核在中断处理中可能唤醒等待进程。
2. **信号触发**：进程收到**异步信号**（如 SIGKILL、SIGSTOP），内核在信号处理时触发调度，强制该进程放弃 CPU。
3. **异常触发**：进程执行非法操作（如访问无效内存、执行特权指令）触发**CPU 异常**，内核处理异常时可能终止或挂起该进程，切换到其他进程。
4. 多核架构的**核间中断**：在多核处理器中，每个核都有独立的执行单元（ALU）和私有状态（寄存器组，PC，L1和L2缓存）。而操作系统的调度器是全局统一的，它维护着所有进程的就绪队列。当一个高优先级进程就绪时，需要立即抢占某个核心的低优先级进程；或者负载均衡时，能将任务从高负载核迁移到低负载核；进程同步时，需要通知到某个核重新执行任务。这些内容的实现就是通过核间中断来实现的。

  # 4. 系统调用

## 4.1 常见的系统调用

​	不同的操作系统中系统调用会不同，以下是linux和windows上常见的系统调用：

|     **功能类别**      | **Unix-like 系统调用**                                       |                     **Windows 系统调用**                     | **核心差异说明**                                             |
| :------------------- | :----------------------------------------------------------- | :---------------------------------------------------------- | :----------------------------------------------------------- |
|     **进程创建**      | `fork()` + `exec()`<br />- `fork()`：复制当前进程生成子进程<br />- `exec()`：替换子进程的代码段 | `CreateProcess()`一次性完成**进程创建 + 程序加载**，<br />需传入可执行文件路径、命令行参数等 | Unix 采用 “先复制、后替换” 的分离式设计；Windows 是一站式创建，更直接 |
|     **进程等待**      | `wait()`/`waitpid()`<br />等待子进程退出并获取退出状态       | `WaitForSingleObject()`<br />`WaitForMultipleObjects()`<br />等待进程句柄或其他内核对象（线程、互斥量等） | Windows 以**内核对象**为核心，等待操作通用化；Unix 针对进程设计专用接口 |
|     **线程管理**      | `pthread_create()`（POSIX 线程库，用户态接口封装系统调用）`clone()`（Linux 特有，可创建轻量级进程 / 线程） |  `CreateThread()`<br />`_beginthreadex()`（C 运行时封装，更安全）  | Unix 原生无线程概念，线程是通过轻量级进程实现；Windows 从内核层支持线程 |
|     **文件操作**      | `open()`/`close()`<br />`read()`/`write()`<br />`lseek()`所有文件（普通文件、设备、管道）<br />统一用**文件描述符**标识 | `CreateFile()``CloseHandle()`<br />`ReadFile()`/`WriteFile()`<br />`SetFilePointer()`<br />用**句柄**标识文件 / 设备 / 内核对象，<br />支持更多参数（如共享模式、访问权限） | Unix 遵循 “一切皆文件”；Windows 区分文件句柄和其他内核对象句柄，参数更复杂 |
|   **文件属性修改**    | `chmod()`（修改权限）<br />`chown()`（修改所有者）<br />`stat()`（获取属性） | `SetFileAttributes()`<br />`GetFileAttributes()`<br />`SetSecurityInfo()`（修改权限） | Unix 文件权限基于 **UID/GID** 模型；Windows 基于 **ACL（访问控制列表）** 模型 |
|     **目录操作**      | `mkdir()`/`rmdir()`<br />`opendir()`/`readdir()`/`closedir()` | `CreateDirectory()`/`RemoveDirectory()`<br />`FindFirstFile()`/`FindNextFile()`/`FindClose()` | Windows 用 “查找” 接口遍历目录；Unix 有专用的目录读写接口    |
|     **内存映射**      | `mmap()`/`munmap()`将文件或设备映射到进程地址空间<br />支持匿名映射（共享内存） | `CreateFileMapping()``MapViewOfFile()`<br />`UnmapViewOfFile()` | Unix `mmap()` 功能更通用；<br />Windows 需先创建文件映射对象，再映射到内存 |
| **进程间通信（IPC）** | - 管道：`pipe()`（匿名）、`mkfifo()`（命名）<br />- 信号：`signal()`/`sigaction()`<br />- 共享内存：`shmget()`/`shmat()`<br />- 消息队列：`msgget()`/`msgsnd()` | - 管道：匿名管道（`CreatePipe`）、<br />命名管道（`CreateNamedPipe`）<br />- 信号量：`CreateSemaphore()`<br />- 共享内存：文件映射（同上）<br />- 消息队列：`CreateMsgQueue`（Windows CE 常用） | Unix IPC 接口分散，部分依赖 System V IPC；<br />Windows IPC 统一基于内核对象，更易管理<br />共享内存只在构建或销毁的时候才会触发系统调用，相比于其他而言效率更高。 |
|     **网络通信**      | `socket()`/`bind()`/`listen()`<br />/`accept()``connect()`<br />/`send()`/`recv()`遵循 POSIX 标准，所有系统通用 | `WSASocket()`/`bind()`/`listen()`/`accept()`<br />`connect()`/`send()`/`recv()`基于 **Winsock 库**，<br />需先调用 `WSAStartup()` 初始化 | 接口名称类似，但 Windows 需初始化 Winsock，部分参数和错误码不同 |
|  **信号 / 中断处理**  | `signal()`/`sigaction()`处理异步信号（如 SIGINT、SIGSEGV）   | `SetConsoleCtrlHandler()`处理控制台事件（如 Ctrl+C）<br />内核级异常通过**结构化异常处理（SEH）** 捕获 | Unix 信号是核心异步通知机制；Windows 更依赖 SEH 和事件驱动模型 |
|     **时间获取**      | `clock_gettime()`（高精度）<br />`gettimeofday()`（毫秒级）  | `QueryPerformanceCounter()`（高精度）<br />`GetSystemTime()`（系统时间） | Windows 高精度计时需用性能计数器；Unix `clock_gettime()` 支持多种时钟 |



## 4.2 支持方式	

系统调用（system call）从 CPU/架构角度看，本质是：

- 用户态执行一条**陷阱类指令**（trap instruction）
- 触发一次**同步异常**（synchronous exception）
- 处理器完成一次**受控的特权级切换**（privilege transition）
- 进入内核预设的入口（entrypoint），由内核根据 **ABI** 解析系统调用号与参数并分发（dispatch）
- 内核完成服务后，再走**特权返回**（privileged return）回到用户态

与此相对的是“硬件中断”（IRQ/FIQ 等），它通常是外设事件驱动的**异步异常**（asynchronous exception），与系统调用的触发时序、入口语义和使用场景不同。

​	系统调用是通过同步异常（trap）把控制权从用户态转移到内核态；差异主要体现在入口/返回路径是否存在**专用快速机制**、硬件自动保存的返回状态形式、以及内核入口代码的保存与分发策略上。在 x86 上，`int 0x80` 依赖通用的 IDT 门分发模型；在 x86_64 上，`syscall/sysret` 提供了更专用的 fast-path，通常显著降低进入/返回开销。在 ARM 上，AArch32 使用 SWI/SVC + 异常向量模型；AArch64 则通过 EL0–EL3 的异常级别体系与 `VBAR_ELx` 向量槽位机制，将 OS syscall（SVC）、虚拟化调用（HVC）与安全调用（SMC）在架构层面清晰分层。

下面就实现系统调用的六个维度来描述系统调用在不同微架构上的实现：

| 维度                          | x86 `int 0x80`              | x86_64 `syscall/sysret`         | AArch32 SWI/SVC          | AArch64 SVC           |
| ----------------------------- | --------------------------- | ------------------------------- | ------------------------ | --------------------- |
| 触发类型                      | 同步异常/陷阱               | 同步异常/陷阱（fast-path）      | 同步异常                 | 同步异常              |
| 入口定位                      | IDT（IDTR→IDT→gate）        | MSR（如 LSTAR/STAR/FMASK）      | 异常向量（传统向量布局） | `VBAR_ELx` 向量槽位   |
| 特权模型                      | ring3→ring0                 | ring3→ring0                     | user→特权模式            | EL0→EL1               |
| 最小返回状态                  | 架构规则保存（配合 `iret`） | `RCX/R11` 等指令语义 + 内核保存 | banked regs/状态         | `ELR_EL1/SPSR_EL1` 等 |
| syscall nr 位置（Linux 常见） | （历史上有约定）            | `RAX`                           | （ABI/内核约定）         | `x8`                  |
| 返回指令                      | `iret/iretq`                | `sysret`（或替代路径）          | 异常返回序列             | 异常返回序列          |

在操作系统层面，不同的操作系统对系统调用的ABI也不相同。

| 维度                               | Linux x86_64 syscall ABI（典型）                             | Windows x86_64 NT syscall ABI（典型）                        |
| ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 进入内核指令（现代）               | `syscall`                                                    | `syscall`                                                    |
| 系统调用号（syscall number）位置   | `RAX`                                                        | `EAX/RAX`（通常由 ntdll stub 填充）                          |
| 参数寄存器（前 6 个）              | 1:`RDI` 2:`RSI` 3:`RDX` 4:`R10` 5:`R8` 6:`R9`                | 常见语义：1:`RCX` 2:`RDX` 3:`R8` 4:`R9`，其余走栈；进入前通常 `RCX→R10` |
| 为什么 Linux 用 `R10` 做第 4 参数  | 因为 `syscall` 会 clobber `RCX`（写入用户返回 RIP），所以linux避免使用RCX作为参数传递寄存器 | N/A                                                          |
| 为什么 Windows 常见 `mov r10, rcx` | N/A                                                          | 因为 `syscall` 会 clobber `RCX`，而 Windows 用户态调用 ABI 把第 1 参数放在 `RCX`；所以需先保存到 `R10` |
| `syscall` 的典型 clobber           | `RCX`（返回 RIP）、`R11`（返回 RFLAGS）                      | 同样如此                                                     |
| 返回值寄存器                       | `RAX`                                                        | `RAX`                                                        |
| 错误语义（常见用户态观感）         | 内核常返回 `-errno`（用户态库转成 `-1` 并设置 `errno`）      | 常返回 `NTSTATUS`（Win32 层再映射到 `GetLastError()` 等）    |
| ABI 稳定性/推荐使用方式            | syscall ABI 相对稳定且公开；可用 `syscall()` 或手写汇编（仍需注意内核版本/策略） | 不鼓励应用直接依赖 syscall number；syscall 号可能随版本变；推荐走 Win32/NT API（由 ntdll 适配） |

所以，总结起来，系统调用的差异来自两个方面：

1. ISA 提供的“特权转换/异常入口机制”（int vs syscall，ARM 的 SVC/异常级别等）；
2. OS 定义并实现的系统调用 ABI 与入口/返回序列（寄存器约定、保存策略、错误语义、安全与兼容策略）。

## 4.3 系统调用的优缺点

优点有：

1. **提供了硬件抽象**：硬件本身种类繁多，但对某类硬件能执行的功能确实有限的。所以操作系统提供了硬件抽象，这大大简化了硬件的使用成本。
2. **提供了安全性**：因为用户程序不会直接操作硬件本身，而是通过中断让操作系统会来操作和管理硬件，这会让整个系统更安全（即便是写了一个很糟糕的程序也不会烧掉硬件）。
3. **提高了程序的可移植性**：对遵守同一类系统调用的用户程序，可以低成本的相互兼容（比如linux和mac os都遵循了同一类系统调用，这意味着他们的兼容相对容易）。

缺点有：

1.  **性能损失**：系统调用的实现依赖于中断，中断则会带来其他额外步骤或者影响：比如context switching，缓存失效带来的性能损失。同时，操作系统是不能保证它是否会立即处理该系统调用，以及如何处理系统调用（可能触发了其他中断或者做其他的调度）。
2.  **平台依赖性**：microsoft和linux的不兼容。

# 5. ABI

## 5.1 编译器视角的ABI

对编译器而言，ABI 是一种 **可组合性（composability）契约**：

> 只要编译器 A 产物与编译器 B 产物都遵守同一 ABI，它们就能在不重新编译对方的情况下链接、调用、展开异常、访问 TLS、与 OS 交互。

### 5.1.1 过程

**1. IR 层：函数签名 + Calling Convention + 属性（影响中后端）**

在 LLVM IR 里，ABI 相关信息至少来自三类：

- **DataLayout / triple**：决定指针大小、对齐、endian、结构体布局等（这部分直接影响类型 lowering）。
- **Calling convention（如 `ccc`/`fastcc`/`tailcc`）**：决定参数/返回的抽象传递模型与一些保存/破坏约束。
- **函数/调用属性**：如 `sret`、`byval`、`inreg`、`noalias`、`noundef`、`musttail` 等，会进一步约束 lowering 与可用优化。

**2. Lowering（类型与调用约定落地）：把“抽象参数”变成“寄存器/栈/内存”**

这一步是 ABI 最核心的编译器工作：**ABI lowering**。决定：

- 参数按顺序怎么映射到寄存器或栈槽（含整数/浮点寄存器文件的分配规则）
- 结构体/大对象如何传递：拆分、间接传递、`sret` 返回地址传参等
- varargs 如何布局（寄存器溢出区、栈对齐规则）
- 返回值怎么放（单寄存器、多寄存器、hidden sret）
- 哪些寄存器必须保存（callee-saved）以及栈帧布局与对齐

**3. 指令选择与 prologue/epilogue：ABI 变成可执行的序列**

当 ABI lowering 给出“应该用哪些寄存器/栈槽”后，后端还要生成：

- 函数序言/尾声（prologue/epilogue）
- 保存/恢复 callee-saved 寄存器
- 栈指针调整与对齐、红区/影子空间（red zone / shadow space）
- 对异常处理/栈展开友好的 CFA/CFI/unwind 信息（平台不同格式不同）

**4. 链接与加载相关**

编译器不仅生成指令，还要生成元数据以满足平台 ABI：

- 符号命名与可见性（name mangling、visibility）
- 重定位与 PLT/GOT 或 IAT 相关的调用模式
- TLS 访问模型（local-exec / initial-exec / global-dynamic…）
- unwind 信息（DWARF CFI vs Windows unwind）

### 5.1.2 编译器视角的“ABI 分层模型”

用编译器最关心的“可观察边界”分三层：

Layer 1：**IR/中间表示层约束（编译器内部接口）**

- 例：LLVM 的 calling convention（`tailcc`/`fastcc`）、`musttail`、`sret`、`byval` 等
- 目标：让优化与后端在一个清晰契约下工作（可预测、可证明）

Layer 2：**平台 ABI（System ABI：跨目标文件/跨编译器互操作）**

- 例：x86_64 SysV ABI vs Windows x64 ABI
- 目标：让不同编译器生成的对象文件能够互相链接、互相调用、正确 unwind

Layer 3：**系统接口 ABI（Syscall ABI：与内核交互）**

- 例：Linux x86_64 syscall：`RAX`=nr，`RDI..R9/R10`=args，`syscall` clobber `RCX/R11`
- 目标：让用户态生成的入口序列能被内核正确解析并安全返回



## 5.2 操作系统视角的ABI

对操作系统而言，ABI 是一种 **可执行环境（execution environment）契约**：

> 规定用户态二进制在该 OS 上“如何被装载、如何调用库、如何请求内核服务、发生异常/信号时如何恢复”，从而保证兼容性与安全性。

### 5.2.1 OS 视角 ABI 的“4 个层面”

1. **装载与链接 ABI（Binary Loading / Linking ABI）**

​	OS 必须能把程序放进内存并让它跑起来，因此需要规定：

- **二进制格式**：Linux 常见 ELF，Windows 常见 PE/COFF
- **入口点与布局**：入口地址、段/节的映射、对齐、权限（RX/RW）
- **动态链接机制**：
  - Linux：ELF + dynamic linker（如 `ld.so`）+ PLT/GOT
  - Windows：PE + loader + IAT/延迟绑定等
- **符号与版本**：如 Linux 的 symbol versioning（glibc 常见）、Windows 的导出表/导入表规则

这一层解决的问题是：**程序如何“启动 + 找到依赖库 + 完成重定位”**。

2. **进程/线程与运行时 ABI（Process/Thread & Runtime ABI）**

​	OS 还要规定运行时语义，例如：

- 进程/线程的创建与销毁语义（`fork/exec` vs `CreateProcess` 等）
- TLS（线程局部存储）模型与访问方式
- 栈的初始布局（argv/envp/auxv 在 Linux 的约定非常典型）
- 资源句柄模型（Linux fd vs Windows HANDLE）
- 异常/信号模型：
  - Linux：信号（signal）与信号栈帧、sigreturn 语义
  - Windows：SEH（结构化异常处理）、unwind 元数据与 dispatcher 机制

这一层解决的是：**程序在 OS 的抽象里如何作为“进程/线程”存在并与运行时机制协同**。

3. **系统调用 ABI（Syscall ABI：用户态 ↔ 内核）**

这是你前面讨论的重点：OS 需要定义用户态如何请求内核服务：

- **入口指令**：x86_64 常用 `syscall`，AArch64 常用 `svc`
- **syscall number**：放哪个寄存器/如何编码
- **参数传递**：用哪些寄存器/栈；哪些寄存器会被 clobber（如 x86_64 `RCX/R11`）
- **返回与错误语义**：
  - Linux：常见 `-errno` 风格（glibc 再设 `errno`）
  - Windows：NTSTATUS / GetLastError 分层

这一层解决的是：**用户态如何“陷入内核 + 传参 + 取回结果”**。

4. **用户态库 ABI（User-space Library ABI / API Surface）**

很多时候应用“看起来”在用 OS，但实际上在用 C 运行库或系统库：

- Linux：glibc、libpthread、libstdc++ 等与其符号/版本兼容
- Windows：kernel32/user32/ntdll/msvcrt/ucrt 等
- Windows 的一个显著特点是：应用通常不直接依赖 syscall 号，而依赖稳定的 Win32/NT API；syscall stub 与 syscall number 属于更内部的实现细节。

这一层解决的是：**OS 生态对应用暴露的“稳定二进制接口面”在哪里**。

# 6. 线程

​	进程的存在可以让用户把某些的业务归为同一类任务的同时，也方便操作系统的统一调度，从而让使用者产生一种”独占“使用电脑的错觉。但是在某些场景下，进程的执行内容需要大量的IO操作。比如：一个服务器进程，它需要同时服务上万个人的访问的同时又要保持很多的数据库操作。在早期的系统中，相当长的时间里这类业务的处理都是启动一个监听进程，根据用户的访问数量在建立相应规模的进程来处理访问IO带来的延迟问题。这带来几个很明显的问题：

1. 因为每个进程都是独立的Context(.text, .data, io resource)，但数量进程数量变多以后，会显著的降低系统中内存的使用率；
2. 因为进程间的内存是相互隔离的，当多个进程间需要通信的时候必须使用进程间通信功能（IPC），这显著的提高了软件复杂度。
3. 创建进程的消耗实际上比较高的，现代操作系统上创建一个进程需要耗费1到10ms，这实际上已经高过了从SSD上读数据的延迟（几十到几百us）。

而线程则正好是解决这两个问题。线程是CPU操作的基础单元，从程序员的角度出发，thread是一种通知操作系统，程序的某部分代码能被并发执行。

- 每一个线程都有一个执行切入点，它通常是一个函数（对应.text上某个位置，由于.text是不变的，所以多个线程可以根据Program Counter寄存器的不同交替访问对应的执行位置）
- 一个进程可以包含任意多个线程，且必须有一个主线程。
- 现代操作系统普遍都使用动态线程管理的机制，也就是用主线程创造任意多的其他线程。当主线程结束，所有的子线程也会被销毁。
- 同属于一个进程的所有线程都共享同一个内存区域和其他资源。
- 为了满足并行执行的目的，每个线程也必须有自己的CPU state，CPU调度器会基于基于每个线程的CPU state来调度线程
- 同时为了高效的局部变量的操作，每个线程还有自己独立的栈指针。
- heap可以作为IPC的替代品，在线程间共享数据。但不属于同一个进程的两个线程之间的通信还是得依赖于IPC。

![image-20260118200724453](C:\Users\jinso\AppData\Roaming\Typora\typora-user-images\image-20260118200724453.png)

参考PCB的定义，在操作系统中thread的表示可以像如下这样子：

```rust
pub struct ProcessControlBlock {
    pid: u64, //进程ID
    
    memory_limits:[u64,2], //用在操作系统中限制进程的访问内存的区域，任何跳出这个区域的进程访问将会被当成错误，以保证安全性。
    
    io_devices: Vec<IO_Device>,
    open_files: Vec<File>,
    
    parent: Arc<ProcessControlBlock>, //父进程
    children: Vec<Arc<ProcessControlBlock>>，//子进程
    
    threads: Vec<Thread_t>, // 线程
}

pub struct Thread_t {
    thread_id: u64, //线程ID
    sate: ProcessState, // 线程的状态
    
    //CPU states
    program_counter: u64, // Address register的快照
    instruction_register: u64, //Instruction register的快照
    general_purpose_register: [u64, 32], //通用寄存器的快照
    flags:[u1;3], //CPU的标志位
    stack_pointer: u64,
    index_registers: [u64; 2],
    
    process_ref: Arc<ProcessControlBlock> //所属线程
}
```

实际上在linux下线程和进程都使用同一种数据结构来表示也就是task_struct。这对采用同一个调度器模块的操作系统来说，大大简化了实现成本。