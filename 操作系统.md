# 0.硬件

CPU本身支持特权模式和非特权模式，在特权模式下所有的指令都能够被执行

# 1. 进程

进程是一个用以区分其他进程的，由以下部分组成的一个context：

1. 程序的指令（.text）和全局数据（.data），这两部分是组成程序的主题。
2. 程序在运行过程中使用到的一些用户输入或者特定情境下的数据（stack与heap）。
3. 在操作系统中用于进程切换的CPU state（General register，Address register（取指的位置），Instruction register（指令寄存器，所有指令通过Address register）和Flags（对比指令执行的依据））。
4. 被该进程打开的文件（比如某个txt文件）或者分配给他的IO设备（比如键盘、鼠标等）。



操作系统通过ProcessControlBlock（PCB）来切换当前系统中的进程，它是一个数据结构包含了上面所提到的所有内容。它能在操作系统中表示一个进程，但是进程更为明确的定义还是一个不可拆分的包含了上面内容的一个上下文（Context）。

PCB的可能构造如下：

```rust
pub struct ProcessControlBlock {
    pid: u64, //进程ID
    sate: ProcessState, // 进程的状态
    
    //CPU states
    program_counter: u64, // Address register的快照
    instruction_register: u64, //Instruction register的快照
    general_purpose_register: [u64, 32], //通用寄存器的快照
    flags:[u1;3], //CPU的标志位
    stack_pointer: u64,
    index_registers: [u64; 2],
    
    memory_limits:[u64,2], //用在操作系统中限制进程的访问内存的区域，任何跳出这个区域的进程访问将会被当成错误，以保证安全性。
    
    io_devices: Vec<IO_Device>,
    open_files: Vec<File>,
    
    parent: Arc<ProcessControlBlock>,
    children: Vec<Arc<ProcessControlBlock>>
}
```

# 2. 处理器模式

​	每种处理器都会支持一个指令集（ISA），指令本身可被分成特权和非特权指令。CPU的运行模式可以分成特权模式（Kernel mode）和受限模式（User mode），在特权模式下指令集中的所有的指令都能够被执行，非特权模式下CPU只能执行部分非特权指令。通常，CPU通过一个特殊的寄存器ModeBit来区分当前CPU是在哪个模式下。

如下是ARM架构中常见的特权和非特权指令的总结：

|    **对比维度**     |                        **非特权指令**                        |                         **特权指令**                         |
| :----------------- | :----------------------------------------------------------  | :---------------------------------------------------------- |
|    **核心定义**     | 可在**所有处理器模式 / 异常级别**执行的通用指令，无系统资源操作权限 | 仅能在**特权模式 / 高异常级别**执行的指令，用于系统级资源管理与配置 |
|    **执行环境**     | - ARMv7：用户模式 + 所有特权模式<br />- ARMv8：EL0（非特权级别）+ EL1~EL3（特权级别） | - ARMv7：仅异常模式、系统模式<br />- ARMv8：仅 EL1~EL3（EL0 执行触发异常） |
| **典型指令 / 操作** | 1. 数据运算：`ADD`/`SUB`/`MUL`/`AND`/`ORR`<br />2. 寄存器传输：`MOV`/`MVN`<br />3. 用户态内存访问：`LDR`/`STR`（用户空间地址）<br />4. 控制流：`B`/`BL`/`BX`（非异常返回）<br />5. 栈操作：`PUSH`/`POP`（用户栈） | 1. 系统寄存器访问：`MRS`/`MSR`（`CPSR`/`SCTLR`）<br />、`MCR`/`MRC`（协处理器）<br />2. 内存管理MMU：`TLBI`（TLB 刷新）、内核空间`LDR`/`STR`<br />3. 模式 / 级别切换：修改`CPSR`模式位、`SMC`（TrustZone）<br />4. 异常触发：`SVC`（ARMv6+）、`SWI`（ARMv6 前）<br />5. 硬件配置：外设寄存器读写、中断控制 |
|  **资源访问范围**   | 仅限**用户空间**资源（应用程序内存、通用寄存器），无法访问内核 / 硬件资源 |    可访问**系统级资源**（内核内存、硬件寄存器、协处理器）    |
|  **异常触发条件**   |    在非特权模式下**访问特权资源**时，触发**数据中止异常**    |     在非特权模式下**直接执行**时，触发**未定义指令异常**     |
|    **应用场景**     |    应用程序逻辑计算、用户态数据处理、无系统资源依赖的代码    | 操作系统内核初始化、中断 / 异常处理、硬件驱动开发、虚拟化 / 安全扩展配置 |
| **ARMv8 关键变化**  |  仅 EL0 为专属非特权级别，指令权限由 `SCTLR_ELx` 寄存器约束  | EL1（内核）、EL2（虚拟化）、EL3（安全监控）均为特权级别，指令权限分级管控 |

# 3. 中断

​	CPU模式的切换通常使用中断（Interrupts）来实现。行为上看，中断像是发送给操作系统的一个信号，该信号会告诉操作系统当前有个事件（比如用户点击了鼠标）发生了，操作系统在接受到这个信号以后会暂停当前正在运行的进程，并且跳转到这个中断对应的执行代码位置。中断的执行通常包含了以下四部分内容：1. 存储被中断进程的状态。2. 处理中断。3. 恢复被中断进程的状态。4.继续执行被中断的进程。

​	普通的用户程序通过操作系统API也就是系统调用来触发某个特定的中断，所有的系统调用在实现中都会在显示的触发某个中断。例如下面的关于打开一个文件的系统调用：

```rust
fn open(filename: String):Result<...> {
    mov rax,2                 // system call number for open
    lea rdi, [ref filename]   // pointer to the file path in RDI(1st argument)
    mov rsi, 0                // File access flags (O_RDONLY = 0)
    mov rdx, 0                // Mode (unused here)
    int 0x80                  // trigger an interrupt
    ret                       // return to caller, file descriptor is in RAX
}
```

​	系统调用本质上相当于程序通过自我中断把CPU控制权交给了操作系统。普通的用户程序除了**主动**使用系统调用来放弃CPU控制权限之外，还可以被动的通过timer来放弃CPU控制权。timer在所有微处理器平台上都有集成（x86 的 PIT/HPET、ARM 的 Global Timer、RISC-V 的 CLINT），如果某个进程一直没有触发系统调用，那么在timer周期性归零以后就会触发定时器中断，在定时器中断中，操作系统会判断当前进程是否用完时间片、是否有更高优先级进程就绪，如果满足就触发进程切换。

​	除了timer之外，以下场景也能使得进程被动放弃CPU：

1. **IO中断触发**：当 I/O 完成时，**外设控制器触发硬件中断**（如磁盘中断、网卡中断），内核在中断处理中可能唤醒等待进程。
2. **信号触发**：进程收到**异步信号**（如 SIGKILL、SIGSTOP），内核在信号处理时触发调度，强制该进程放弃 CPU。
3. **异常触发**：进程执行非法操作（如访问无效内存、执行特权指令）触发**CPU 异常**，内核处理异常时可能终止或挂起该进程，切换到其他进程。
4. 多核架构的**核间中断**：在多核处理器中，每个核都有独立的执行单元（ALU）和私有状态（寄存器组，PC，L1和L2缓存）。而操作系统的调度器是全局统一的，它维护着所有进程的就绪队列。当一个高优先级进程就绪时，需要立即抢占某个核心的低优先级进程；或者负载均衡时，能将任务从高负载核迁移到低负载核；进程同步时，需要通知到某个核重新执行任务。这些内容的实现就是通过核间中断来实现的。

  # 4. 系统调用

## 4.1 常见的系统调用

​	不同的操作系统中系统调用会不同，以下是linux和windows上常见的系统调用：

|     **功能类别**      | **Unix-like 系统调用**                                       |                     **Windows 系统调用**                     | **核心差异说明**                                             |
| :------------------- | :----------------------------------------------------------- | :---------------------------------------------------------- | :----------------------------------------------------------- |
|     **进程创建**      | `fork()` + `exec()`<br />- `fork()`：复制当前进程生成子进程<br />- `exec()`：替换子进程的代码段 | `CreateProcess()`一次性完成**进程创建 + 程序加载**，<br />需传入可执行文件路径、命令行参数等 | Unix 采用 “先复制、后替换” 的分离式设计；Windows 是一站式创建，更直接 |
|     **进程等待**      | `wait()`/`waitpid()`<br />等待子进程退出并获取退出状态       | `WaitForSingleObject()`<br />`WaitForMultipleObjects()`<br />等待进程句柄或其他内核对象（线程、互斥量等） | Windows 以**内核对象**为核心，等待操作通用化；Unix 针对进程设计专用接口 |
|     **线程管理**      | `pthread_create()`（POSIX 线程库，用户态接口封装系统调用）`clone()`（Linux 特有，可创建轻量级进程 / 线程） |  `CreateThread()`<br />`_beginthreadex()`（C 运行时封装，更安全）  | Unix 原生无线程概念，线程是通过轻量级进程实现；Windows 从内核层支持线程 |
|     **文件操作**      | `open()`/`close()`<br />`read()`/`write()`<br />`lseek()`所有文件（普通文件、设备、管道）<br />统一用**文件描述符**标识 | `CreateFile()``CloseHandle()`<br />`ReadFile()`/`WriteFile()`<br />`SetFilePointer()`<br />用**句柄**标识文件 / 设备 / 内核对象，<br />支持更多参数（如共享模式、访问权限） | Unix 遵循 “一切皆文件”；Windows 区分文件句柄和其他内核对象句柄，参数更复杂 |
|   **文件属性修改**    | `chmod()`（修改权限）<br />`chown()`（修改所有者）<br />`stat()`（获取属性） | `SetFileAttributes()`<br />`GetFileAttributes()`<br />`SetSecurityInfo()`（修改权限） | Unix 文件权限基于 **UID/GID** 模型；Windows 基于 **ACL（访问控制列表）** 模型 |
|     **目录操作**      | `mkdir()`/`rmdir()`<br />`opendir()`/`readdir()`/`closedir()` | `CreateDirectory()`/`RemoveDirectory()`<br />`FindFirstFile()`/`FindNextFile()`/`FindClose()` | Windows 用 “查找” 接口遍历目录；Unix 有专用的目录读写接口    |
|     **内存映射**      | `mmap()`/`munmap()`将文件或设备映射到进程地址空间<br />支持匿名映射（共享内存） | `CreateFileMapping()``MapViewOfFile()`<br />`UnmapViewOfFile()` | Unix `mmap()` 功能更通用；<br />Windows 需先创建文件映射对象，再映射到内存 |
| **进程间通信（IPC）** | - 管道：`pipe()`（匿名）、`mkfifo()`（命名）<br />- 信号：`signal()`/`sigaction()`<br />- 共享内存：`shmget()`/`shmat()`<br />- 消息队列：`msgget()`/`msgsnd()` | - 管道：匿名管道（`CreatePipe`）、<br />命名管道（`CreateNamedPipe`）<br />- 信号量：`CreateSemaphore()`<br />- 共享内存：文件映射（同上）<br />- 消息队列：`CreateMsgQueue`（Windows CE 常用） | Unix IPC 接口分散，部分依赖 System V IPC；<br />Windows IPC 统一基于内核对象，更易管理<br />共享内存只在构建或销毁的时候才会触发系统调用，相比于其他而言效率更高。 |
|     **网络通信**      | `socket()`/`bind()`/`listen()`<br />/`accept()``connect()`<br />/`send()`/`recv()`遵循 POSIX 标准，所有系统通用 | `WSASocket()`/`bind()`/`listen()`/`accept()`<br />`connect()`/`send()`/`recv()`基于 **Winsock 库**，<br />需先调用 `WSAStartup()` 初始化 | 接口名称类似，但 Windows 需初始化 Winsock，部分参数和错误码不同 |
|  **信号 / 中断处理**  | `signal()`/`sigaction()`处理异步信号（如 SIGINT、SIGSEGV）   | `SetConsoleCtrlHandler()`处理控制台事件（如 Ctrl+C）<br />内核级异常通过**结构化异常处理（SEH）** 捕获 | Unix 信号是核心异步通知机制；Windows 更依赖 SEH 和事件驱动模型 |
|     **时间获取**      | `clock_gettime()`（高精度）<br />`gettimeofday()`（毫秒级）  | `QueryPerformanceCounter()`（高精度）<br />`GetSystemTime()`（系统时间） | Windows 高精度计时需用性能计数器；Unix `clock_gettime()` 支持多种时钟 |

## 4.2 支持方式	

系统调用这个机制是非常成功的一个设计，以至于一些微处理器专门为它提供了专用指令，比如：

1. x86下的`int 0x80`(通用指令，触发软中断，软中断的设计是为了通用化，早期的设备驱动、调试场景就是通过软中断来实现的，所以包含了大量兼容代码；实现上，需要先检查中断描述表（IDT），验权，跳转内核处理函数；进入时，cpu会自动保存大量的通用寄存器，恢复时候开销也大)
2. x86_64下的`syscall`和`sysret`（专用指令，性能远高于 `int 0x80`，通过 `rax` 传系统调用号，`rdi/rsi/rdx` 等传参数，`rcx` 保存返回地址；实现上，跳过IDT查表的操作，内核的处理入口提前固化/配置在了专用MSR寄存器中；恢复时候只保存必要的寄存器（如`RCX`存储返回地址、`R11`存储原`RFLAGS`），恢复时候开销小）
3. ARMv7下的SVC（老叫法SWI）（**upervisor Call** 的缩写，指令可带立即数（如 `SVC #0`），用于传递系统调用号。 Linux ARM 架构的标准系统调用指令）
4. ARMv8（AArch64）下的`SVC`/`HVC`/`SMC`（\- `SVC`：普通系统调用，进入 EL1 内核态；- `HVC`：虚拟化调用，进入 EL2 虚拟机监控器；-`SMC`：安全调用，进入 EL3 安全监控层（TrustZone 架构）。他们都通过 `x8` 寄存器传递系统调用号）
5. RISC-V下的`ecall`

## 4.3 系统调用的优缺点

优点有：

 	1. **提供了硬件抽象**：硬件本身种类繁多，但对某类硬件能执行的功能确实有限的。所以操作系统提供了硬件抽象，这大大简化了硬件的使用成本。
 	2. **提供了安全性**：因为用户程序不会直接操作硬件本身，而是通过中断让操作系统会来操作和管理硬件，这会让整个系统更安全（即便是写了一个很糟糕的程序也不会烧掉硬件）。
 	3. **提高了程序的可移植性**：对遵守同一类系统调用的用户程序，可以低成本的相互兼容（比如linux和mac os都遵循了同一类系统调用，这意味着他们的兼容相对容易）。

缺点有：

1.  **性能损失**：系统调用的实现依赖于中断，中断则会带来其他额外步骤或者影响：比如context switching，缓存失效带来的性能损失。同时，操作系统是不能保证它是否会立即处理该系统调用，以及如何处理系统调用（可能触发了其他中断或者做其他的调度）。
2. **平台依赖性**：microsoft和linux的不兼容。

# 5. 线程

​	进程的存在可以让用户把某些的业务归为同一类任务的同时，也方便操作系统的统一调度，从而让使用者产生一种”独占“使用电脑的错觉。但是在某些场景下，进程的执行内容需要大量的IO操作。比如：一个服务器进程，它需要同时服务上万个人的访问的同时又要保持很多的数据库操作。在早期的系统中，相当长的时间里这类业务的处理都是启动一个监听进程，根据用户的访问数量在建立相应规模的进程来处理访问IO带来的延迟问题。这带来几个很明显的问题：

1. 因为每个进程都是独立的Context(.text, .data, io resource)，但数量进程数量变多以后，会显著的降低系统中内存的使用率；
2. 因为进程间的内存是相互隔离的，当多个进程间需要通信的时候必须使用进程间通信功能（IPC），这显著的提高了软件复杂度。
3. 创建进程的消耗实际上比较高的，现代操作系统上创建一个进程需要耗费1到10ms，这实际上已经高过了从SSD上读数据的延迟（几十到几百us）。

而线程则正好是解决这两个问题。线程是CPU操作的基础单元，从程序员的角度出发，thread是一种通知操作系统，程序的某部分代码能被并发执行。

- 每一个线程都有一个执行切入点，它通常是一个函数（对应.text上某个位置，由于.text是不变的，所以多个线程可以根据Program Counter寄存器的不同交替访问对应的执行位置）
- 一个进程可以包含任意多个线程，且必须有一个主线程。
- 现代操作系统普遍都使用动态线程管理的机制，也就是用主线程创造任意多的其他线程。当主线程结束，所有的子线程也会被销毁。
- 同属于一个进程的所有线程都共享同一个内存区域和其他资源。
- 为了满足并行执行的目的，每个线程也必须有自己的CPU state，CPU调度器会基于基于每个线程的CPU state来调度线程
- 同时为了高效的局部变量的操作，每个线程还有自己独立的栈指针。
- heap可以作为IPC的替代品，在线程间共享数据。但不属于同一个进程的两个线程之间的通信还是得依赖于IPC。

![image-20260118200724453](C:\Users\jinso\AppData\Roaming\Typora\typora-user-images\image-20260118200724453.png)

参考PCB的定义，在操作系统中thread的表示可以像如下这样子：

```rust
pub struct ProcessControlBlock {
    pid: u64, //进程ID
    
    memory_limits:[u64,2], //用在操作系统中限制进程的访问内存的区域，任何跳出这个区域的进程访问将会被当成错误，以保证安全性。
    
    io_devices: Vec<IO_Device>,
    open_files: Vec<File>,
    
    parent: Arc<ProcessControlBlock>, //父进程
    children: Vec<Arc<ProcessControlBlock>>，//子进程
    
    threads: Vec<Thread_t>, // 线程
}

pub struct Thread_t {
    thread_id: u64, //线程ID
    sate: ProcessState, // 线程的状态
    
    //CPU states
    program_counter: u64, // Address register的快照
    instruction_register: u64, //Instruction register的快照
    general_purpose_register: [u64, 32], //通用寄存器的快照
    flags:[u1;3], //CPU的标志位
    stack_pointer: u64,
    index_registers: [u64; 2],
    
    process_ref: Arc<ProcessControlBlock> //所属线程
}
```

实际上在linux下线程和进程都使用同一种数据结构来表示也就是task_struct。这对采用同一个调度器模块的操作系统来说，大大简化了实现成本。