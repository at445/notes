# 一、词法分析器

**结果**：（单词种别，单词自身的值）的一个二元组。二元组的最后一元可以有多种表示形式，它可以是一个结果，也可也是一个符号表中的一个指针，只要能界定结果就可以。

1. 若一个种别只有一个单词符号，则使用种别编码就够了。常见的 **基本字**、**运算符**、**界定符**都是这类情况。
2. 若一个种别有多个单词符合，那么一个种别编码就不够了，还需要给出单词自身的值。比如**标识符、常量**就是这类情况。

**特点**：

1. 逻辑上说词法分析器是一个独立的阶段，但是为了效率，基本都不把它当成一个独立的阶段，而是作为一个子程序来处理。
2. 语法分析器来调用它，它返回上面提到的二元组。

**词法分析的挑战（超前搜索）**：

1. 标识符的识别，字母开头的字母数字串，后跟界定符或者运算符。
2. 常量识别，比如5E08，需要多看几步才能决定他是常量还是标识符。
3. 运算符，比如+=， ++， --。这些都需要提前看一步。

现代语言中几点通用限制，为了避免过多的超前搜索。比如：

- **所有的基本字都是保留字，程序员不得赋予它其他意义**；
- 所以的基本字使用**保留字表**被当成了特殊的标识符来处理；
- 基本字、标识符、常量之间如果没有确定的运算符或者界符作为间隔，则中间必须加一个空格来作为界定符。

**分析方法-状态图**

定义：

1. 节点代表了状态，用圆圈表示。
2. 状态之间用带箭头的弧连接，弧上标注了该状态下可以接受的字符或者字符串。
3. 一张图包含有限个状态，其中至少有一个初态，一个终态。
4. 若存在一条从初态到某一终态的道路，而且这条路上的所有弧上的标记连接成的字等于$\alpha$，则称$\alpha$能被该状态转换图所识别。

状态图的实现方法：

​    总体思维：每个状态节点作为一小段程序，由几种固定的模式拼接成整个任务。

​    具体的拼接模式：

1. 对不含由回路的分叉节点，使用switch或者if-else语句来实现。
2. 对含有回路的状态节点，使用一段由while结构或者if结构构成的程序来实现。
3. 终态节点表示已经识别出某种单词符号，对应的语句应该是return(C, val)。

​    更一般的可以使用**数据驱动的表来实现**，状态被编码成int，状态的转换使用一个二维表来表示。

# 二、正规表达式和有限自动机

## 1. **几个基本概念**

-  一个字符的集合构成了**字母表$\Sigma$**。

- **字母表$\Sigma$**中的每一个元素称为一个**字符**。

- **字母表$\Sigma$**上的**字**是由它的字符所构成的一个有穷的序列。

- 有个特殊的字是**空字$\varepsilon$**，表示这个字的构成中没有使用任何字母表中任何一个字符。

- **$\Sigma^*$** 表示了**字母表$\Sigma$**上的字的全体，它包括了空字$\epsilon$，是个无穷的集合。

  例如：设$\Sigma$ = (a,b)， 则**$\Sigma^*$** = {$\varepsilon$, a, b, aa, ab, ba, bb, aaa, ...}

- **$\Sigma^*$** 的子集**$U$和$V$的连接（积）**定义为$UV=\{\alpha\beta | \alpha \in U \& \beta \in V\}$

- **$V$自身的n次积**记作$V^n=VV...V$。

- 规定$V^0 = \{\varepsilon\}$。

- 规定$V^*=V^0 \cup V^1 \cup V^2 \cup ...$  ；$V^*$表示**$V$的闭包**。

-  规定$V^+=V V^*$  ；$V^+$表示**$V$​​的正规闭包**。

## 2. **正规式和正规集**

### 2.1 定义

- 字的全体$\Sigma^*$中有一类特殊的子集，这类子集中的字都可以使用**正规表达式**来表示。
- 可以使用正规式表达的所有字的集合就是**正规集**。
- 正规表达式是正规集的**一种表达方式**。
- 一个字的集合是正规集**当且仅当**它能**使用正规式表示**。
- $\varepsilon$ 和$\emptyset$都是字母表$\Sigma$上的正规式，它门所表示的正规集是$\{\varepsilon\}$和$\emptyset$​。

### 2.2 对应关系

假设$e_1$和$e_2$都是$Sigma$上的正规式，它们对应的正规集分别是$L(e_1)$和$L(e_2)$。那么有以下几条性质：

1. $e_1$|$e_2$是$Sigma$上的正规式，它对应的正规集是$L(e_1) \cup L(e_2)$。
2. $e_1e_2$是$Sigma$上的正规式，它对应的正规集是$L(e_1)L(e_2)$。也就是$L(e_1)$和$L(e_2)$的积。
3. $e_1*$是$Sigma$上的正规式，它对应的正规集是$(L(e_1))^*$，也就是$L(e_1)$的闭包。

总的来说，**正规式是一套描述正规集的命名体系，正规集是实在的全字子集。**

### 2.3 性质

一个正规集的描述可能有多个正规式。比如b(ab)* = (ba)*b，(a * b*) * = (a|b)*。

正规式有以下性质：

1. 交换律， $e_1 | e_2$ = $e_2 | e_1$
2. 结合律， $e_1 | (e_2 | e_3)$ = $(e_1 | e_2) | e_3$​
3. 结合律， $e_1  (e_2  e_3)$ = $(e_1  e_2)  e_3$​
4. 分配律，$e_1(e_2|e_3) = e_1e_2|e_1e_3$
5. 分配律，$(e_1|e_2)e_3 = e_1e_3|e_2e_3$​
6. $e\varepsilon = \varepsilon e = e$
7. $e_1e_2 <> e_2e_1$

## 3. 有限自动机（FA）

### 3.1 确定有限自动机（DFA）

- 确定有限自动机可表示成一个五元组$M = (S, \Sigma, f, S_0, F)$， 其中

  1. $S$ 表示一个有穷的状态集。
  1. $\Sigma$ 表示一个字母表。
  1. $f$ 表示状态转换函数，它是$S \times \Sigma \rightarrow S$的单值部分的映射。$f(s,a) = s^{'}$表示当前状态为$s$，在接收到字符串$a$时，将转换成$s^{'}$ 。
  1. $S_0 \in S$，它表示**唯一**的一个初态。
  1. $F$表示终态，它可以为空也可也有多个，$F \subset S$​。


- 它的其他表示方式还有状态转移图和转移矩阵。
- 对于$\Sigma^*$中的任何字$\alpha$， 若存在一条从初态到某一终态的道路，这条道路上所有弧上的标记**字符**连接起来等于$\alpha$，那么$\alpha$能被DFA所识别。
-  DFA M所能识别的字的全体被记作L(M)。

### 3.2 非确定有限自动机（NFA）

- 非确定有限自动机跟确定有限自动机一样，也形式化成一个五元组$M = (S, \Sigma, f, S_0, F)$， 其中

  1. $S$ 表示一个有穷的状态集。
  2. $\Sigma$ 表示一个字母表。
  3. $f$ 表示状态转换函数，它是$S \times \Sigma^* \rightarrow 2^S$的部分映射。$2^S$表示$S$的密集，他是集合$S$的所有子集构成的集合。（这就是非确定的由来，一个状态接收一个字或者字符转移的结果不只有一个）
  4. $S_0 \subset S$，它的初态是不唯一的，但是不能为空。
  5. $F$表示终态，它可以为空也可也有多个，$F \subset S$​。


- 对于$\Sigma^*$中的任何字$\alpha$， 若存在一条从某一初态到某一终态的道路，这条道路上所有弧上的标记的**字**连接起来等于$\alpha$，那么$\alpha$能被NFA所识别。
-  NFA M所能识别的字的全体被记作L(M)。

### 3.3 NFA和DFA的区别

下图是状态转移图

![image-20240519152346141](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240519152346141.png)

- 根据上面的图可以看出NFA和DFA的区别：

  1. NFA可以有多个初态，DFA只有一个
  2. NFA弧上的标记可以是$\Sigma^*$中的任意一个字或者干脆是一个正规式，而DFA只能是$Sigma$中的一个字符。
  3. 同一个字可能出现同状态射出的多条弧上，这也就是说NFA在状态确定和输入确定的情况不存在唯一后继状态。而DFA则严格满足唯一后继状态。
  4. 所以DFA是NFA的一个特例。


- 如果有两个有限自动状态机M和M‘，如果L(M) = L(M')，则M于M‘**等价**。这个**等价判断的算法是存在的**。
- 对于每个NFA来说都有一个DFA能与之等价，所以NFA和DFA的描述能力是相同的。

### 3.4 NFA到DFA的转换方法

步骤一：引入新的初态节点$X$和终态节点$Y$，$X,Y \notin S$，从$X$到$S_0$中所有状态节点连接一条$\varepsilon$  

弧，从F中所有状态节点连接一条$\varepsilon$弧到Y。

步骤二： 对于NFA上的弧上的标记的字按照如下三条规则，拆分成一个一个字符。

1. 对于ab形式的正规式，加入中一个新的状态，这个状态接受a到这个状态，接受b转移到另一个状态。

2. 对于a|b形式的正规式，裁成两个弧，分别是a和b。

3. 对于a*形式的正规式，引入一个性的装，这个状态接受a转移到自己，与老状态的连接都使用$\varepsilon$​弧。

   <img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240519162553742.png" alt="image-20240519162553742" style="zoom: 67%;" />

步骤三：使用子集法发确定NFA（消除$\varepsilon$和状态转移的不确定性）

子集法：

* 假设I是状态集的一个子集，**I的$\varepsilon$-闭包（$\varepsilon$-closure(I)）**定义为：

  1. 若$s \in I$，则$s \in \varepsilon-closure(I)$。
  2. 若$s \in I$，则经过$s$出发的任意一条$\varepsilon$弧能到达的任何状态$s^{'}$都属于$\varepsilon$-closure(I)

  所以$\varepsilon$-closure(I)的形式化定义为：

  $\varepsilon-closure(I)$ = $I \cup \{s^{'} | 从某个s \in I出发经过任意多条\varepsilon 弧能到达的状态\}$。 

* 假设$a$是$\Sigma$中的一个字符，定义**集合$I_a = \varepsilon-closure(J)$**，其中$J$为$I$中的某个状态经过$a$弧而到达的状态集合

