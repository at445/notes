# 形式语言描述

## 1. **几个基本概念**

- 一个字符的集合构成了**字母表$\Sigma$**。

- **字母表$\Sigma$**中的每一个元素称为一个**字符**。

- **字母表$\Sigma$**上的**字**是由它的字符所构成的一个有穷的序列。

- 有个特殊的字是**空字$\varepsilon$**，表示这个字的构成中没有使用任何字母表中任何一个字符。

- **$\Sigma^*$** 表示了**字母表$\Sigma$**上的字的全体，它包括了空字$\epsilon$，是个无穷的集合。

  例如：设$\Sigma$ = (a,b)， 则**$\Sigma^*$** = {$\varepsilon$, a, b, aa, ab, ba, bb, aaa, ...}

- **$\Sigma^*$** 的子集**$U$和$V$的连接（积）**定义为$UV=\{\alpha\beta | \alpha \in U \& \beta \in V\}$

- **$V$自身的n次积**记作$V^n=VV...V$。

- 规定$V^0 = \{\varepsilon\}$。

- 规定$V^*=V^0 \cup V^1 \cup V^2 \cup ...$  ；$V^*$表示**$V$的闭包**。

- 规定$V^+=V V^*$  ；$V^+$表示**$V$​​​的正规闭包**。

## 2. 形式语言的种类

形式语言的描述都有四部分组成。

$G = (V_t, V_n, S, P)$其中：

$V_t$:表示终结符的结合（非空）。 $V_n$:表示非终结符（非空）。$S$：表示文法的开始符合，$S \in V_n$。 $P$:表示产生式有限集。

产生式的种类不同，形式语言的种类也不同。一共有四种，表述能力依次减弱：

1. 0型文法（短文语法，图灵机）：形如$\alpha \rightarrow \beta$， 其中$\alpha \in (V_t \cup V_n)*$且至少包含一个非终结符；$\beta \in (V_t \cup V_n)*$。

2. 1型文法（上下文有关文法，线性界限自动机）：形如$\alpha \rightarrow \beta$， 其中$|\alpha| \le |\beta|$， 只有$S \rightarrow \varepsilon$例外。

3. 2型文法（上下文无关文法，非确定下推自动机）：形如$\alpha \rightarrow \beta$， 其中$\alpha \in V_n$；$\beta \in (V_t \cup V_n)*$​。而且S必须出现推导式的左边一次。

4. 3型文法（正规文法，有限自动机）：

   a. 右线性文法：形如$A \rightarrow \alpha B$或$A \rightarrow \alpha$，其中$\alpha \in V_t*$; $A, B \in V_n$​。

   b. 左线性文法：形如$A \rightarrow B \alpha$或$A \rightarrow \alpha$，其中$\alpha \in V_t*$; $A, B \in V_n$​。

## 3. 基本概念

**直接推出**：$\alpha A \gamma \Rightarrow \alpha \beta \gamma$，当且仅当$A \rightarrow \beta$式一个产生式，且$\alpha , \gamma \in (V_t \cup v_n)*$。

**推导**：如果$\alpha_1 \Rightarrow \alpha_2 \Rightarrow ... \Rightarrow \alpha_n$，则我们称这个序列为$\alpha_1$到$\alpha_n$的一个推导，若存在一个$\alpha_1$到$\alpha_n$的推导，那么称$\alpha_1$可以推导出$\alpha_n$。

$α_1 \mathop{\Rightarrow} \limits^*  α_n$  从$α_1$出发，经过0步或若干步推出$α_n$。

$α_1 \mathop{\Rightarrow} \limits^+  α_n$  从$α_1$出发，经过1步或若干步推出$α_n$。

**句型**：如果$S \mathop{\Rightarrow} \limits^* \alpha$，则$\alpha$是该文法的一个句型。

**句子**：只有终结符的句型是一个句子。

**语言**：文法G所产生的句子的全体是一个语言，$L(G) = \{\alpha | S \mathop{\Rightarrow} \limits^+ \alpha, \alpha \in {V_t}^*\}$​

**最左推导**：一个句型到另一个句型的推导如果总是以最左边的非终结符开始，那么这个推导就是最左推导。

**最右推导**：一个句型到另一个句型的推导如果总是以最右边的非终结符开始，那么这个推导就是最右推导。

**语法树**：使用一张图来表示一个句型的推导过程，称为语法树，它是不同推导过程的共性抽象，使用最左推导或者最右推导都能得到一颗唯一的树。

**文法二义性**：对一个句子来说，如果按照某个文法可以推出两颗不同的语法树，那么这个文法是二义的。

**语言的二义性**：如果语言不存在无二义文法，那么语言就是二义的。

比如对于表达式的上下文无关文法描述下面的描述是二义的：

$G(E) : E \rightarrow i | E+E | E*E|(E)$

下面的描述是无二义的：

$G(E) : E \rightarrow T | E+T$

$T \rightarrow F|T*F$

$F \rightarrow (E)|i$

这说明语言可以有多种不同文法的写法，一些文法的写法可能是二义的，但不能说明该语言是二义的。

# 一、词法分析器

## 1. 简述

**结果**：（单词种别，单词自身的值）的一个二元组。二元组的最后一元可以有多种表示形式，它可以是一个结果，也可也是一个符号表中的一个指针，只要能界定结果就可以。

1. 若一个种别只有一个单词符号，则使用种别编码就够了。常见的 **基本字**、**运算符**、**界定符**都是这类情况。
2. 若一个种别有多个单词符合，那么一个种别编码就不够了，还需要给出单词自身的值。比如**标识符、常量**就是这类情况。

**特点**：

1. 逻辑上说词法分析器是一个独立的阶段，但是为了效率，基本都不把它当成一个独立的阶段，而是作为一个子程序来处理。
2. 语法分析器来调用它，它返回上面提到的二元组。

**词法分析的挑战（超前搜索）**：

1. 标识符的识别，字母开头的字母数字串，后跟界定符或者运算符。
2. 常量识别，比如5E08，需要多看几步才能决定他是常量还是标识符。
3. 运算符，比如+=， ++， --。这些都需要提前看一步。

现代语言中几点通用限制，为了避免过多的超前搜索。比如：

- **所有的基本字都是保留字，程序员不得赋予它其他意义**；
- 所以的基本字使用**保留字表**被当成了特殊的标识符来处理；
- 基本字、标识符、常量之间如果没有确定的运算符或者界符作为间隔，则中间必须加一个空格来作为界定符。

**分析方法-状态图**

定义：

1. 节点代表了状态，用圆圈表示。
2. 状态之间用带箭头的弧连接，弧上标注了该状态下可以接受的字符或者字符串。
3. 一张图包含有限个状态，其中至少有一个初态，一个终态。
4. 若存在一条从初态到某一终态的道路，而且这条路上的所有弧上的标记连接成的字等于$\alpha$，则称$\alpha$能被该状态转换图所识别。

状态图的实现方法：

​    总体思维：每个状态节点作为一小段程序，由几种固定的模式拼接成整个任务。

​    具体的拼接模式：

1. 对不含由回路的分叉节点，使用switch或者if-else语句来实现。
2. 对含有回路的状态节点，使用一段由while结构或者if结构构成的程序来实现。
3. 终态节点表示已经识别出某种单词符号，对应的语句应该是return(C, val)。

​    更一般的可以使用**数据驱动的表来实现**，状态被编码成int，状态的转换使用一个二维表来表示。

## 2. 正规表达式和有限自动机

### 2.1. **几个基本概念**

-  一个字符的集合构成了**字母表$\Sigma$**。

- **字母表$\Sigma$**中的每一个元素称为一个**字符**。

- **字母表$\Sigma$**上的**字**是由它的字符所构成的一个有穷的序列。

- 有个特殊的字是**空字$\varepsilon$**，表示这个字的构成中没有使用任何字母表中任何一个字符。

- **$\Sigma^*$** 表示了**字母表$\Sigma$**上的字的全体，它包括了空字$\epsilon$，是个无穷的集合。

  例如：设$\Sigma$ = (a,b)， 则**$\Sigma^*$** = {$\varepsilon$, a, b, aa, ab, ba, bb, aaa, ...}

- **$\Sigma^*$** 的子集**$U$和$V$的连接（积）**定义为$UV=\{\alpha\beta | \alpha \in U \& \beta \in V\}$

- **$V$自身的n次积**记作$V^n=VV...V$。

- 规定$V^0 = \{\varepsilon\}$。

- 规定$V^*=V^0 \cup V^1 \cup V^2 \cup ...$  ；$V^*$表示**$V$的闭包**。

-  规定$V^+=V V^*$  ；$V^+$表示**$V$​​的正规闭包**。

### 2.2. **正规式和正规集**

#### 2.2.1 定义

- 字的全体$\Sigma^*$中有一类特殊的子集，这类子集中的字都可以使用**正规表达式**来表示。
- 可以使用正规式表达的所有字的集合就是**正规集**。
- 正规表达式是正规集的**一种表达方式**。
- 一个字的集合是正规集**当且仅当**它能**使用正规式表示**。
- $\varepsilon$ 和$\emptyset$都是字母表$\Sigma$上的正规式，它门所表示的正规集是$\{\varepsilon\}$和$\emptyset$​。

#### 2.2.2 对应关系

假设$e_1$和$e_2$都是$\Sigma$上的正规式，它们对应的正规集分别是$L(e_1)$和$L(e_2)$。那么有以下几条性质：

1. $e_1$|$e_2$是$\Sigma$上的正规式，它对应的正规集是$L(e_1) \cup L(e_2)$。
2. $e_1e_2$是$\Sigma$上的正规式，它对应的正规集是$L(e_1)L(e_2)$。也就是$L(e_1)$和$L(e_2)$的积。
3. $e_1*$是$\Sigma$上的正规式，它对应的正规集是$(L(e_1))^*$，也就是$L(e_1)$的闭包。

总的来说，**正规式是一套描述正规集的命名体系，正规集是实在的全字子集。**

#### 2.2.3 性质

一个正规集的描述可能有多个正规式。比如b(ab)* = (ba)*b，(a * b*) * = (a|b)*。

正规式有以下性质：

1. 交换律， $e_1 | e_2$ = $e_2 | e_1$
2. 结合律， $e_1 | (e_2 | e_3)$ = $(e_1 | e_2) | e_3$​
3. 结合律， $e_1  (e_2  e_3)$ = $(e_1  e_2)  e_3$​
4. 分配律，$e_1(e_2|e_3) = e_1e_2|e_1e_3$
5. 分配律，$(e_1|e_2)e_3 = e_1e_3|e_2e_3$​
6. $e\varepsilon = \varepsilon e = e$
7. $e_1e_2 <> e_2e_1$

### 2.3. 有限自动机（FA）

#### 2.3.1 确定有限自动机（DFA）

- 确定有限自动机可表示成一个五元组$M = (S, \Sigma, f, S_0, F)$， 其中

  1. $S$ 表示一个有穷的状态集。
  1. $\Sigma$ 表示一个字母表。
  1. $f$ 表示状态转换函数，它是$S \times \Sigma \rightarrow S$的单值部分的映射。$f(s,a) = s^{'}$表示当前状态为$s$，在接收到字符串$a$时，将转换成$s^{'}$ 。
  1. $S_0 \in S$，它表示**唯一**的一个初态。
  1. $F$表示终态，它可以为空也可也有多个，$F \subset S$​。


- 它的其他表示方式还有状态转移图和转移矩阵。
- 对于$\Sigma^*$中的任何字$\alpha$， 若存在一条从初态到某一终态的道路，这条道路上所有弧上的标记**字符**连接起来等于$\alpha$，那么$\alpha$能被DFA所识别。
-  DFA M所能识别的字的全体被记作L(M)。

#### 2.3.2 非确定有限自动机（NFA）

- 非确定有限自动机跟确定有限自动机一样，也形式化成一个五元组$M = (S, \Sigma, f, S_0, F)$， 其中

  1. $S$ 表示一个有穷的状态集。
  2. $\Sigma$ 表示一个字母表。
  3. $f$ 表示状态转换函数，它是$S \times \Sigma^* \rightarrow 2^S$的部分映射。$2^S$表示$S$的密集，他是集合$S$的所有子集构成的集合。（这就是非确定的由来，一个状态接收一个字或者字符转移的结果不只有一个）
  4. $S_0 \subset S$，它的初态是不唯一的，但是不能为空。
  5. $F$表示终态，它可以为空也可也有多个，$F \subset S$​。


- 对于$\Sigma^*$中的任何字$\alpha$， 若存在一条从某一初态到某一终态的道路，这条道路上所有弧上的标记的**字**连接起来等于$\alpha$，那么$\alpha$能被NFA所识别。
-  NFA M所能识别的字的全体被记作L(M)。

#### 2.3.3 NFA和DFA的区别

下图是状态转移图

![image-20240519152346141](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240519152346141.png)

- 根据上面的图可以看出NFA和DFA的区别：

  1. NFA可以有多个初态，DFA只有一个
  2. NFA弧上的标记可以是$\Sigma^*$中的任意一个字或者干脆是一个正规式，而DFA只能是$Sigma$中的一个字符。
  3. 同一个字可能出现同状态射出的多条弧上，这也就是说NFA在状态确定和输入确定的情况不存在唯一后继状态。而DFA则严格满足唯一后继状态。
  4. 所以DFA是NFA的一个特例。


- 如果有两个有限自动状态机M和M‘，如果L(M) = L(M')，则M于M‘**等价**。这个**等价判断的算法是存在的**。
- 对于每个NFA来说都有一个DFA能与之等价，所以NFA和DFA的描述能力是相同的。

#### 2.3.4 NFA到DFA的转换方法

步骤一：引入新的初态节点$X$和终态节点$Y$，$X,Y \notin S$，从$X$到$S_0$中所有状态节点连接一条$\varepsilon$  弧，从F中所有状态节点连接一条$\varepsilon$弧到Y。

步骤二： 对于NFA上的弧上的标记的字按照如下三条规则，拆分成一个一个字符。

1. 对于ab形式的正规式，加入中一个新的状态，这个状态接受a到这个状态，接受b转移到另一个状态。

2. 对于a|b形式的正规式，裁成两个弧，分别是a和b。

3. 对于a*形式的正规式，引入一个的装，这个状态接受a转移到自己，与老状态的连接都使用$\varepsilon$​弧。

   <img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20240519162553742.png" alt="image-20240519162553742" style="zoom: 67%;" />

步骤三：使用子集法发确定NFA（消除$\varepsilon$和状态转移的不确定性）

子集法：

* 假设I是状态集的一个子集，**I的$\varepsilon$-闭包（$\varepsilon$-closure(I)）**定义为：

  1. 若$s \in I$，则$s \in \varepsilon-closure(I)$。
  2. 若$s \in I$，则经过$s$出发的任意一条$\varepsilon$弧能到达的任何状态$s^{'}$都属于$\varepsilon$-closure(I)

  所以$\varepsilon$-closure(I)的形式化定义为：

  $\varepsilon-closure(I)$ = $I \cup \{s^{'} | 从某个s \in I出发经过任意多条\varepsilon 弧能到达的状态\}$。 

* 假设$a$是$\Sigma$中的一个字符，定义**集合$I_a = \varepsilon-closure(J)$**，其中$J$为$I$中的某个状态经过$a$弧而到达的状态集合

#### 2.3.5 DFA的化简

**状态的等价性**：假设$s$和$t$是有限状态机$M$​的两个状态，

​     充分条件，从$s$出发，如果读入任意一个字$\alpha$停止于终态，对应的从$t$出发读入$\alpha$也会停止于终态，那么$s$和$t$等价。

​     必要条件：$s$和$t$等价是指如果从状态$s$出发读到某个字$\alpha$会停止于终态，那么从$t$状态出发读到相同的字$\alpha$也会停止于终态；

两个状态如果不等价，那么说他们**是可区别的**。

**也就是只要存在一个字$\alpha$如果状态$s$接收该字到达终态，而状态$t$接收该字到达不了终态，那么$s$和$t$就是可区别的。**



**简化的基本思想**：把$M$的状态集划分成一些不相交的子集，使得任何两个不同子集的状态是可区别的，而同一子集的任何两个状态是等价的。

**简化的过程**：

1. 把$S$划分成终态和非终态两个子集，形成基本划分$\phi$。

2. 检查$\phi$​中的每个子集，看他们是否能做进一步的划分，如果能划分则继续划分。直到所有的子集都不能再划分为止。

   ​     假设$\phi = \{I^1, I^2, ..., I^m\}$, 其中$I^k$(其中$k$在1和m之间)，$I^k$包含了$k$个状态。

   ​     对于一个输入的字符$a$使得某个$I_a^{(i)}$不会被包含在$\phi$中现有的某个子集，那么至少可以把$I^{i}$划分成两个部分。

3. 若一个子集中包含原来的初态或者终态，那么这个子集就是新的初态或者终态。

4. 选取每个子集的其中一个代表，消去其他状态。这样就得到了简化后的DFA。

### 2.4 FA和正规式等价性

**FA到正规式的转换**：

结论：任何一个有限自动机$M$都存在一个正规式$r$与之等价。 使得$L(M) = L(r)$， 前一个L表示有限自动机识别字的全体，后一个L表示正规式对应的正规集。



步骤一：引入新的初态节点$X$和终态节点$Y$，$X,Y \notin S$，从$X$到$S_0$中所有状态节点连接一条$\varepsilon$  弧，从F中所有状态节点连接一条$\varepsilon$弧到Y。得到$M^{'}$，这时候$L(M) = L(M^{'})$

步骤二：在$M^{'}$​上，使用3.4节步骤二的逆变换得到从刚加入的初态到终态的唯一转换，转换弧上的标记就是得到的正规式。



**正规式到NFA的转换**：

结论：任何一个正规式$r$都存在一个有限自动机$M$与之等价。 使得$L(r) = L(M)$。这个有限自动机M只有一个初态和一个终态，而且没有从终态发出的弧。



步骤一：确定一个初态和一个终态，初态射出一个弧到终态，弧上的标记为该正规式。得到一个FA $M^{'}$。

步骤二：在$M^{'}$​上，使用3.4节步骤二的变换得到从刚加入的初态到终态的唯一转换，转换弧上的标记就是得到的正规式。

### 2.5. 词法分析生成器（Lex）

**输入一**：辅助定义，比如 $letter \rightarrow A|B|...|Z$   $digit \rightarrow 0|1|...|9$

**输入二**：识别规则，比如:  

​	$DIM \rightarrow (1, -)$

​	$IF \rightarrow (2, -)$

​        $DO \rightarrow (3, -)$

​        $letter(letter|digit)* \rightarrow (6, TOKEN)$

​        $digit(digit)* \rightarrow (7, NUMBER)$

​        $* \rightarrow (8, -)$

​        $+ \rightarrow (9, -)$



**过程**：

      1. 对每条规则构建一个相应的非确定有限自动机。
      2. 加入一个新初态X，通过$\varepsilon$弧将这些自动机连接成一个新的NFA。
      3. 再把新得到的NFA通过确定化转换为DFA，通过算法简化DFA。
      4. 生成对应的状态转换表和控制执行程序。

# 二、语法分析

**语法分析器的功能**：按照文法的产生式（语言的语法规则），识别输入符号串是否为一个句子（合适的程序）。

## 1. 分类

**自下而上的分析方法**：

- 基本思想：从输入串开始，逐步进行规约，直到文法的开始符号。
- 规约的过程：根据文法的产生式规则，把串中出现的产生式的右部替换成左部符号。
- 顺序：从树叶节点开始，构造语法树。
- 常见的算法：算符优先分析法、LR分析法。

**自上而下的分析方法**：

- 基本思想：文法的开始符号出发，反复使用各种产生式，寻找“匹配”的推导。
- 推导的过程：根据文法的产生式规则，把串中出现的产生式左部符号替换成右部符号。
- 顺序：从树叶的根开始，构造语法树。
- 常见的算法：递归下降法、预测分析程序。



## 2. 自上而下的分析

两个问题：

1. 在产生式中，如果右边的规则有多种选择，这时候暂时的匹配成功可能是错的，需要读入更多的token才能确定，如果出错，需要有**回溯动作**。
2. 文法的左递归问题，存在这样的推导$P \mathop{\Rightarrow} \limits^* Pa$​， 这样语法树会不断增加，但是句子不会被读入，程序死循环。

### 2.1 左递归的消除

**直接左递归的消除**：

​	假定P的全部产生式是$P \rightarrow P\alpha_1 | P\alpha_2| ... | P\alpha_m | \beta_1 |\beta_2 |...|\beta_n$

​	那么可以直接转换成$P \rightarrow \beta_1P^{'} | \beta_2P^{'} | ... | \beta_nP^{'}$

​					   $P^{'} \rightarrow \alpha_1P^{'} | \alpha_2P^{'} | ... | \alpha_mP^{'} | \varepsilon$

**间接左递归的消除**：

步骤一：把文法G的所有非终结符按照任意一种顺序排序$P_1, P_2, ..., P_n$。

步骤二：伪代码

for i = 1 to n Do:

​	for j = 1 to i-1 Do:

​		把形如$P_i \rightarrow P_jr$的规则改写成$P_i \rightarrow \delta_1r | \delta_2r |...|\delta_kr$（其中$P_i \rightarrow \delta_1 | \delta_2 |...|\delta_k$是关于$P_j$的所有规则。

​		消除关于$P_i$的直接左递归

步骤三：简化步骤二所得的的文法，去除开始符号出发永远无法到达的非终结符的产生规则。

​			

### 2.2 LL(1)分析方法





